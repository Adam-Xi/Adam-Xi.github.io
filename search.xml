<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++初探</title>
    <url>/2019/11/12/C++%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h3 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h3><p>C++98/03中，关键字共有<strong>63</strong>个<br><img src="https://img-blog.csdnimg.cn/20190913211553864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>C++11中，关键字共有<strong>73</strong>个：在前面的基础上，新加了alignas、alignof、char16_t、char32_t、constexpr、decltype、noexcept、nullptr、static_assert、thread_local，并对少数几个关键字进行了一定的修改。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在C/C++中，变量、函数和类都是大量存在的，这些变量、函数、类的名称都将作用于全局作用域中，可能会导致很多的冲突。所以，C++中引入namespace关键字，目的是<strong>对标识符的名称进行本地化，以避免命名冲突或名字污染</strong></p>
<h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>1、普通的命名空间 ： namespace关键字， 后面跟命名空间的名字， 然后一对花括号{}即可 ，{}中即为命名空间的成员。<strong>命名空间中的内容，可以是变量，也可以是函数</strong><br>2、命名空间可以嵌套<br>3、同一工程中，允许存在多个相同名称的命名空间，编译器最后会将它们合成到同一个命名空间中<br>4、<strong>一个命名空间就是定义了一个作用域</strong>，命名空间中定义的所有内容的作用范围都局限于该命名空间中</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><blockquote>
<p>三种使用方式：<br>1、加命名空间名称及作用域限定符“ :: ”<br>2、使用using将命名空间中的成员导入<br>3、使用using namespace + 命名空间名称将该命名空间中的成员全部引入</p>
</blockquote>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace N</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	int Add(int left, int right)</span><br><span class="line">	&#123;</span><br><span class="line">		return left + right;</span><br><span class="line">	&#125;</span><br><span class="line">	namespace X</span><br><span class="line">	&#123;</span><br><span class="line">		int c = 10;</span><br><span class="line">		int d = 20;</span><br><span class="line">		int Mul(int left, int right)</span><br><span class="line">		&#123;</span><br><span class="line">			return left * right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using N :: b; //方式2</span><br><span class="line"></span><br><span class="line">using namespace N; //方式3</span><br><span class="line"></span><br><span class="line">using N :: X :: c;</span><br><span class="line">using N :: X :: d;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; N :: a &lt;&lt; endl; //方式1</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; N :: a &lt;&lt; endl; //方式2</span><br><span class="line">	cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; //方式3</span><br><span class="line">	cout &lt;&lt; Add(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; N :: X :: Mul(c, d) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-输入-amp-amp-输出"><a href="#C-输入-amp-amp-输出" class="headerlink" title="C++输入 &amp;&amp; 输出"></a>C++输入 &amp;&amp; 输出</h3><p>输入 cin &gt;&gt; 变量1 &gt;&gt; 变量2 &gt;&gt; … ;<br>输出 cout &lt;&lt; 变量/常量/函数 &lt;&lt; … ( &lt;&lt; endl 表示输出后换行,可加可不加) ;</p>
<p>说明：<br>1、使用 cout（标准输出：控制台）和 cin（标准输入：键盘）时，<strong>必须包含<iostream>头文件以及std标准命名空间</strong>，如上述例子<br>2、使用C++输入输出更加方便，不需要增加数据格式控制，如：整形–%d，字符型–%c 等</p>
<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。<br>缺省参数分为全缺省参数和半缺省参数<br>注意：<br>1、半缺省参数必须<strong>从右往左</strong>依次来给出，不能间隔着给<br>2、缺省参数<strong>不能在函数声明和定义中同时出现</strong>。如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那么编译器会因为无法确定用哪个缺省值而报错<br>3、缺省值必须是<strong>常量</strong>或<strong>全局变量</strong><br>4、C语言不支持（编译器不支持）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Func1(int a = 1, int b = 2, int c = 3) //全缺省参数</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">void Func2(int a, int b = 2, int c = 3) //半缺省参数</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Fun1();</span><br><span class="line">	Func1(10);</span><br><span class="line">	Func2(10);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><blockquote>
<p>函数重载是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表（参数个数或类型或顺序）必须不同，常用来处理实现功能类似数据类型不同的问题。</p>
</blockquote>
<p>注意：<strong>几个同名函数要形成函数重载，只与函数的参数列表有关</strong>，函数的参数个数、类型、顺序只要其中之一不同，就能形成函数重载。<strong>与返回值类型无关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Add(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">	return left + right;</span><br><span class="line">&#125;</span><br><span class="line">double Add(double left, double right)</span><br><span class="line">&#123;</span><br><span class="line">	return left + right;</span><br><span class="line">&#125;</span><br><span class="line">long Add(long left, long right)</span><br><span class="line">&#123;</span><br><span class="line">	return left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Add(10, 20);</span><br><span class="line">	Add(10.0, 20.0);</span><br><span class="line">	Add(10L, 20L);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="名字修饰-name-Mangling"><a href="#名字修饰-name-Mangling" class="headerlink" title="名字修饰(name Mangling)"></a>名字修饰(name Mangling)</h6><p>在C/C++中，一个程序要运行起来，需要经历以下几个阶段：<strong>预处理、编译、汇编、链接</strong>。<br>Name Mangling是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过某种算法，重新修饰为一个全局唯一的名称。<br><strong>C语言的名字修饰规则，是在函数名字前面加下划线</strong>，因此当工程中存在相同函数名的函数时，就会产生冲突，所以C语言并不支持函数重载。</p>
<p>由于C++要支持函数重载、命名空间等，使其修饰规则较为复杂，不同编译器在底层的产生方式都有可能产生差异。<br>在VS下，编译器在底层使用的不是函数名字，而是被重新修饰过的一个比较复杂的名字，<strong>被重新修饰后的名字中包含了：函数的名字以及参数类型</strong>。这就是为什么函数重载中几个同名函数要求其参数列表不同的原因，<strong>只要参数列表不同，编译器在编译时通过对函数名字进行重新修饰，将参数类型包含在最终的名字中，就可以保证名字在底层的唯一性</strong>。</p>
<h5 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h5><p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思就是告诉编译器，将函数按照C语言规则来编译</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h6><p>引用不是新定义的一个变量，而是给已存在的变量取了一个<strong>别名</strong>，编译器不会为引用变量开辟空间，它和它引用的变量共用同一块内存空间。<br>类型&amp; 引用变量名(对象名) = 引用实体；<br><strong>注意：引用类型必须和引用实体是同种类型的</strong></p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>1、引用在定义时必须<strong>初始化</strong><br>2、<strong>一个变量可以有多个引用</strong><br>3、<strong>引用一旦引用一个实体，再不能引用其他实体</strong>。这就是它为什么要被初始化的原因<br>4、在实际的程序中，引用主要被用做函数的形式参数，通常将类对象传递给一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Func()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	//int&amp; ra;  //该条语句编译时会出错，未初始化</span><br><span class="line">	int&amp; ra = a;</span><br><span class="line">	int&amp; rra = a;</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; &amp;ra &lt;&lt; &amp;rra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h6><p>const引用可以用不同类型的对象初始化(只要能从一种类型转换到另一种类型即可)，也可以是不可寻址的值，如文字常量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	const int a = 10;</span><br><span class="line">	//int&amp; ra = a;    //该语句编译时会出错，a为常量</span><br><span class="line">	const int&amp; ra = a;</span><br><span class="line">	//int&amp; b = 10;    //该语句编译时会出错，b为常量</span><br><span class="line">	const int&amp; b = 10;</span><br><span class="line"></span><br><span class="line">	double d = 12.34;</span><br><span class="line">	//int&amp; rd = d;    //该语句编译时会出错，类型不同</span><br><span class="line">	const int&amp; rd = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>1、做参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 采用引用做函数的参数</span><br><span class="line">void Swap(int&amp; left, int&amp; right)</span><br><span class="line">&#123;</span><br><span class="line"> int temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意： 如果想要通过形参改变外部实参，形参类型：普通类型引用</span><br><span class="line">//       如果不想通过形参改变外部实参，形参类型：const类型引用</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int a = 10;</span><br><span class="line"> int&amp; ra = a;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、做返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引用：可以作为函数的返回值</span><br><span class="line">int g_a = 0;</span><br><span class="line"></span><br><span class="line">int&amp; Add(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line"> int ret = left + right;</span><br><span class="line"> return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sub(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line"> int ret = left - right;</span><br><span class="line"> return ret;</span><br><span class="line">&#125;</span><br><span class="line">// 注意：不要返回函数栈上的空间</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int&amp; r = Add(1, 2);</span><br><span class="line"> //Sub(10, 5);</span><br><span class="line"> Add(3, 4);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果函数返回时，离开函数作用域后，其栈上的空间已经返还给系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制（即比函数生命周期长）</p>
<h6 id="传值、传引用效率比较"><a href="#传值、传引用效率比较" class="headerlink" title="传值、传引用效率比较"></a>传值、传引用效率比较</h6><p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回值变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // 传参效率比较：传值最慢(值得拷贝)，传地址和传引用效率几乎一样</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> struct A</span><br><span class="line"> &#123;</span><br><span class="line">	 int a[10000];</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void TestFunc1(A* a)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> void TestFunc2(A&amp; a)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> void TestRefAndValue()</span><br><span class="line"> &#123;</span><br><span class="line">	 A a;</span><br><span class="line">	// 以值作为函数参数</span><br><span class="line">	size_t begin1 = clock();</span><br><span class="line">	 for (size_t i = 0; i &lt; 10000; ++i)</span><br><span class="line">		 TestFunc1(&amp;a);</span><br><span class="line">	 size_t end1 = clock();</span><br><span class="line"></span><br><span class="line">	 // 以引用作为函数参数</span><br><span class="line">	 size_t begin2 = clock();</span><br><span class="line">	 for (size_t i = 0; i &lt; 10000; ++i)</span><br><span class="line">		 TestFunc2(a);</span><br><span class="line">	 size_t end2 = clock();</span><br><span class="line">	 // 分别计算两个函数运行结束后的时间</span><br><span class="line">	 cout &lt;&lt; &quot;TestFunc1(int*)-time:&quot; &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">	 cout &lt;&lt; &quot;TestFunc2(int&amp;)-time:&quot; &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 运行多次，检测值和引用在传参方面的效率区别</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">	 for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">	 &#123;</span><br><span class="line">		 TestRefAndValue();</span><br><span class="line">	 &#125;</span><br><span class="line">	 return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>同样，值和引用作为返回值类型的性能同样差距很大。</p>
<h6 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h6><p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间<br>在底层实现上实际是有空间的，因为<strong>引用是按照指针的方式来实现的</strong><br>具体区别如下：<br>1、引用在定义时必须初始化，指针没有要求<br>2、引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体<br>3、没有NULL引用，但有NULL指针<br>4、在sizeof中含义不同：<strong>引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）</strong><br>5、引用自加即引用的实体加1，指针自加即指针向后偏移一个类型的大小<br>6、有多级指针，但是没有多级引用<br>7、访问实体方式不同，<strong>指针需要显示解引用</strong>，<strong>引用编译器自己处理</strong><br>8、引用比指针使用起来相对安全</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><blockquote>
<p>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升了程序的运行效率。</p>
</blockquote>
<p>特性：<br>1、inline是一种<strong>以空间换时间</strong>的做法，省去函数调用的额外开销。所以<strong>代码很长或者有循环/递归函数不宜使用作为内联函数</strong><br>2、inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等，编译器优化时会忽略掉内联函数<br>3、<strong>inline不建议声明和定义分离</strong>，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到</p>
<h3 id="auto关键字（C-11）"><a href="#auto关键字（C-11）" class="headerlink" title="auto关键字（C++11）"></a>auto关键字（C++11）</h3><p>在C++11中，auto被赋予了全新的含义：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须有编译器在编译时期推导而得</p>
<pre><code>// 编译器在编译阶段，根据提供的初始化表达式实际类型，来确定变量的类型

int main()
{
    auto a = 10;
    auto b = 12.34;
    //auto c;  //无法编译通过，使用auto定义变量时必须对其进行初始化
    cout &lt;&lt; typeid(a).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;
    return 0;
}</code></pre><p>注意：使用auto定义变量时必须对其进行初始化，在编译阶段需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型</p>
<h6 id="auto使用细则"><a href="#auto使用细则" class="headerlink" title="auto使用细则"></a>auto使用细则</h6><p>1、auto与指针和引用结合起来使用<br>用auto声明指针类型时，<strong>用auto和auto*没有任何区别</strong>，但<strong>用auto声明引用类型时必须加&amp;</strong><br>2、在同一行定义多个变量<br><strong>当在同一行声明多个变量时，这些变量必须是相同的类型</strong>，否则编译器会报错 ，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其它变量<br>3、<strong>auto不能作为函数的参数</strong>，因为编译器无法对形参的类型进行推导<br>4、<strong>auto不能直接用来声明数组</strong><br>5、为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法<br>6、auto在实际中最常见的优势用法就是C++11中提供的<strong>新式for循环</strong>，还有<strong>lambda表达式</strong>等进行配合使用<br>7、auto不能定义类的非静态成员变量<br>8、实例化模板时不能使用auto作为模板参数</p>
<h3 id="基于范围的for循环-C-11"><a href="#基于范围的for循环-C-11" class="headerlink" title="基于范围的for循环(C++11)"></a>基于范围的for循环(C++11)</h3><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>在C++98中，若要编译一个数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] *= 2;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int* p = arr; p &lt; arr + sizeof(arr)/sizeof(arr[0]); p++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个有范围的集合而言，由程序员说明循环的范围是多余的，有时候还会容易出错。因此C++11中引入了基于范围的for循环。for循环后面的括号中有冒号“:”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;</span><br><span class="line">	for(auto&amp; e : arr)  //让变量e去引用数组中的每一个元素</span><br><span class="line">	&#123;</span><br><span class="line">		e *= 2;</span><br><span class="line">	&#125;</span><br><span class="line">	for(auto e : arr)  //变量e就是数组中每个元素的拷贝</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通for循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环</p>
<h6 id="范围for的使用条件"><a href="#范围for的使用条件" class="headerlink" title="范围for的使用条件"></a>范围for的使用条件</h6><p>1、for循环迭代的范围必须是确定的<br>对于数组而言，就是数组中第一个元素和最后一个元素的范围；<br>对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围<br>2、迭代的对象要实现++和==的操作</p>
<h3 id="指针空值"><a href="#指针空值" class="headerlink" title="指针空值"></a>指针空值</h3><h6 id="C-98中的空值"><a href="#C-98中的空值" class="headerlink" title="C++98中的空值"></a>C++98中的空值</h6><p>在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针，如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">    int* p1 = NULL;</span><br><span class="line">    int* p2 = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NULL实际上是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef NULL</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">#define NULL   0</span><br><span class="line">#else </span><br><span class="line">#define NULL   ((void *)0)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void *)的常量。<br>但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强制类型转换(void *)0</p>
<h6 id="nullptr-与-nullptr-t"><a href="#nullptr-与-nullptr-t" class="headerlink" title="nullptr 与 nullptr_t"></a>nullptr 与 nullptr_t</h6><p>为考虑兼容性，C++11中并没有消除常量0的二义性，C++11中给出了全新的nullptr表示空值指针。C++11为什么不在NULL的基础上进行扩展，这是因为NULL以前就是一个宏，而且不同编译器厂商对于NULL的实现可能不大相同，而且直接扩展NULL，可能会影响到以前旧的程序。因此，为了避免混淆，C++11中提供了nullptr，即nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类型<br>注意：<br>1、在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的<br>2、在C++11中，sizeof(nullptr) 与 sizeof((void *)0) 所占字节数相同<br>3、为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C总结</title>
    <url>/2019/11/12/C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190921234557107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本指令</title>
    <url>/2019/11/11/Linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>本篇文章中，对Linux中的基本指令的常用用法进行讲解，对于刚接触linux系统的童鞋来说比较友好，不足之处，还望批评指出！</p>
<p>正文：</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>语法：ls [选项] [目录或文件]<br>功能：对于目录，将列出该目录下所有子目录和文件；对于文件，将列出文件的所有信息<br>常用选项：</p>
<blockquote>
<p>-a：列出目录下的所有文件，包含隐含文件<br>-l： 列出文件的详细信息<br>-r： 对目录反向排序<br>-t： 以时间排序<br>-R： 递归列出所有子目录下的文件</p>
</blockquote>
<h6 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h6><p>1、各种选项可以进行组合使用<br>2、这里只列举几种最常用的选项，并不是所有的选项</p>
<h6 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h6><blockquote>
<p>ls  //列出当前目录下的文件和目录名称<br>ls -a  //列出当前目录下的所有文件和目录名称<br>ls -l   //列出当前目录下的文件和目录的详细信息，可简写为 ll<br>ls -a -l   //列出当前目录下的所有文件和目录的详细信息，可简写为 ls -la<br>ls -l -t    //以时间排序，距现在最近的创建修改时间的文件或目录排在最前面（顶部），简写为 ls -lt<br>ls -l -r -t  //以时间反向排序，距现在最近的文件或目录排在最底部，简写 ls -lrt ，这条命令非常实用方便</p>
</blockquote>
<p>注意：该用例中的所有简写方式中的选项组合没有先后之分，且文章往后都默认没有，若有次序之分，会实现说明</p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>语法：pwd<br>功能：显示用户当前所在的目录，即路径</p>
<h6 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h6><p>该命令经常单用，显示当前用户所在的目录，且显示的路径是绝对路径</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>语法：cd 目录名/<br>功能：改变工作目录，将当前工作目录改变到指定的目录下<br>常用搭配：</p>
<blockquote>
<p>cd ~ ： 进入用户的家目录<br>cd - ： 返回上一次访问的目录<br>cd / ： 返回根目录<br>cd /home/adam_xi/workstation/ : 绝对路径<br>cd ./ ： 切换到当前目录（没变）<br>cd ../ ： 切换到上层目录（返回到“父节点”）<br>cd ../test/ ：相对路径<br>cd 目录名/</p>
</blockquote>
<h6 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h6><p>1、在Linux系统中，磁盘上的文件和目录被组织成一棵目录树，每个节点都是目录或文件<br>从目录树的根节点到某个节点的路径称为绝对路径<br>从目录树中的当前节点改变到某个节点的路径称为相对路径<br>2、Linux目录结构中，任一目录下都会有 <strong>.</strong> 和 <strong>..</strong> 两个默认<strong>隐藏目录</strong>, .为当前目录， ..为上层目录</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>语法：touch [选项] [路径下的文件名]<br>功能：可更改文档或目录的日期时间（创建时间，存取时间），最主要的功能是<strong>创建新文件</strong><br>选项：</p>
<blockquote>
<p>-a ： 只更改存取时间<br>-d ： 使用指定的日期时间<br>-m ： 只更改变动时间<br>-r ：  把指定文档或目录的时间日期，全部更改为和参考文档或目录的日期时间相同<br>-t ： 使用指定的日期时间，而非现在的时间</p>
</blockquote>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>语法：mkdir [选项] [目录名]<br>功能：在当前目录下创建一个目录<br>选项：</p>
<blockquote>
<p>-p ： 后面可以跟一个路径名称，若路径中某些目录不存在，加上此选项后，将自动生成不存在的目录，即一次性创建多个目录<br>例：mkdir grap/father/child ：递归创建多个目录</p>
</blockquote>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>语法：rm [选项] [文件名/目录名]<br>功能：删除文件后目录<br>选项：</p>
<blockquote>
<p>-f ： 即使文件属性为只读，也直接删除<br>-i ： 删除前逐一询问确认<br>-r ： 删除目录及以下所有文件</p>
</blockquote>
<h6 id="tips-2"><a href="#tips-2" class="headerlink" title="tips"></a>tips</h6><p>1、该操作适用所有使用者<br>2、删除要慎用<br>尤其rm -rf / 一般情况下禁止使用，它会删除linux系统中所有的文件，不要问我为什么知道-_-</p>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>语法：man [选项] [指令名]<br>功能：查看联机手册<br>选项：</p>
<blockquote>
<p>-k ： 根据关键字搜索联机帮助<br>num ： 只在第num章节找<br>-a ： 将所有的章节都显示出来</p>
</blockquote>
<h6 id="tips-3"><a href="#tips-3" class="headerlink" title="tips"></a>tips</h6><p>1、Linux中有很多的命令，参数，我们不可能全都记住，那么，有一个man的指令查询命令就帮助我们进行查询<br>2、man手册分为八个章节<br>（1）、普通的命令<br>（2）、系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)<br>（3）、库函数,如printf,fread<br>（4）、特殊文件,也就是/dev下的各种设备文件<br>（5）、指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义<br>（6）、给游戏留的,由各个游戏自己定义<br>（7）、附件还有一些变量,比如向environ这种全局变量在这里就有说明<br>（8）、系统管理用的命令,这些命令只能由root使用,如ifconfig</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>语法：cp [选项] [源文件或目录] [目标文件或目录]<br>功能：复制文件或目录<br>常用选项：</p>
<blockquote>
<p>-f ： 强制复制，不管文件或目录是否打开<br>-i ： 覆盖文件之前询问用户<br>-r ： 递归处理，将指定目录下的文件与子目录一并处理</p>
</blockquote>
<h6 id="tips-4"><a href="#tips-4" class="headerlink" title="tips"></a>tips</h6><p>用于复制文件或目录，如果同时指定两个以上的文件或目录，且最后一个的目的地是另一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时制定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>语法：mv [选项] [源文件或目录] [目标文件或目录]<br>功能：<br>1、当第二个参数是目录时，移动操作<br>2、当第二个参数是文件时，重命名操作</p>
<p>常用选项：</p>
<blockquote>
<p>-f ： 如果目标文件已存在，不询问而直接覆盖<br>-i ： 如果目标文件已存在，询问是否覆盖</p>
</blockquote>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>语法：cat [选项] [文件]<br>功能：查看目标文件的内容，适合小文件，全部展示<br>常用选项：</p>
<blockquote>
<p>-b ： 对非空输出行编号<br>-n ： 对输出的所有行编号<br>-s ： 不输出多行空格</p>
</blockquote>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>语法：more [选项] [文件]<br>功能：more命令，功能类似cat，适合大文件，分页展示，并且只能向下翻页<br>选项：</p>
<blockquote>
<p>-n ： 对输出的所有行编号<br>q ： 退出more</p>
</blockquote>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>语法：less [选项] [文件]<br>功能：类似more，适合更大的文件，在查看之前不会加载整个文件，且能进行前后翻页</p>
<p>选项：</p>
<blockquote>
<p>-i ： 忽略搜索时的大小写<br>-N ： 显示每行的行号<br>/字符串 ： 向下搜索字符串<br>?字符串 ： 向上搜索字符串<br>n ： 重复前一个搜索，具体与/或?有关<br>N ： 反向重复前一个搜索<br>q ： 退出</p>
</blockquote>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>语法：head -n&lt;行数&gt; 文件名<br>功能：从头开始展示n行文件内容</p>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>语法：rear [选项] 文件名<br>功能：从尾开始展示文件内容，常用于日志文件的读取</p>
<blockquote>
<p>-f ： 循环读取<br>-n&lt;行数&gt; ： 显示行数</p>
</blockquote>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>1、date以指定格式显示时间：</p>
<blockquote>
<p>[adam_xi@bogon ~]$ date<br>Sun Oct 27 19:01:33 CST 2019</p>
</blockquote>
<p>就我而言，感觉date功能查看时间方面挺鸡肋的，所以省去了具体介绍<br>2、date可以设置系统时间，不过当系统联网后，会自动校验回正确时间</p>
<blockquote>
<p>date -s //设置当前时间，不过需要root权限</p>
</blockquote>
<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>语法：cal [参数] [月份][年份]<br>功能：用于查看日历等时间信息，如只有一个参数，则表示年份，如有两个参数，则表示月份和年份<br>常用选项：</p>
<blockquote>
<p>-3 ： 显示系统前一个月，本月和下一个月的日历<br>-j ： 显示在本年中是第几天<br>-y ：显示当前年份的日历</p>
</blockquote>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>语法：find 路径名 -选项<br>功能：用于在文件树中查找文件，并做出相应处理<br>常用选项：</p>
<blockquote>
<p>-name ： 按照文件名查找文件</p>
</blockquote>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>语法：grep [选项] 搜寻字符串 文件<br>功能：在文件中搜索字符串，将找到的行打印出来<br>常用选项：</p>
<blockquote>
<p>-i ： 忽略大小写不同<br>-n ： 输出行号<br>-v ： 反向选择，显示出没有“搜寻字符串”内容的那一行</p>
</blockquote>
<h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><p>语法：zip&nbsp; [压缩文件.zip]&nbsp; [目录或文件]&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unzip [要解压的压缩文件] &nbsp;[目录或文件名]<br>功能：将目录或文件压缩成zip格式<br>常用选项：</p>
<blockquote>
<p>-r ： 递归处理，将指定目录下的所有文件和子目录一并处理</p>
</blockquote>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>语法：tar [参数] [文件与目录]<br>功能：打包，解包，即处理压缩文件<br>常用选项：</p>
<blockquote>
<p>-c ： 建立一个压缩文件<br>-x ： 解开一个压缩文件<br>-z ： 是否需要用gzip算法压缩或解压<br>-j ： 是否需要用bzip2算法压缩或解压<br>-v ： 压缩的过程显示文件<br>-f ： 使用档名，即规定压缩或解压后文件的名称，注意：使用该参数后后面不能再跟其他参数，直接跟文件名<br>-C ： 解压到指定目录<br>综合用法：<br>tar -cvzf 压缩后的文件名称 要压缩的文件名称  //用gzip算法进行压缩，并展示压缩过程<br>tar -xvzf 解压后的文件名称 要解压的文件名称  //解压缩<br>tar -cjzf 压缩后的文件名称 要压缩的文件名称  //用bzip2算法进行压缩，并展示压缩过程<br>tar -xjzf 解压后的文件名称 要解压的文件名称  //解压缩</p>
</blockquote>
<h6 id="tips-5"><a href="#tips-5" class="headerlink" title="tips"></a>tips</h6><p>1、一般的压缩算法有gzip和bzip2两种，使用tar命令需要说明使用的哪种算法进行压缩或解压的 -z 或 -j<br>2、用哪种算法压缩的就需要用哪种算法进行解压<br>3、用gzip压缩后的文件若要进行解压，文件名必须为xxx.tar.gz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用bzip2压缩后的文件若要进行解压，文件名必须为xxx.tar.bz2<br>4、再次强调，参数-f后需要直接跟文件名，不能再跟其他参数，但是-f之前的其他参数可以以任意次序进行混合使用</p>
<h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>语法：uname [选项]<br>功能：用来获取电脑和操作系统的相关信息，可以显示Linux主机所用的版本，硬件名称等基本信息<br>常用选项</p>
<blockquote>
<p>-a 详细展示所有信息</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>STL之deque</title>
    <url>/2019/11/11/STL%E4%B9%8Bdeque/</url>
    <content><![CDATA[<h3 id="deque介绍"><a href="#deque介绍" class="headerlink" title="deque介绍"></a>deque介绍</h3><p>1、deque是动态大小的序列式容器，可以向两端进行扩容或压缩<br>2、特定的库可以以不同的方式实现deque，但通常都是一种动态数组。不论在何种情况下，它都允许通过随机访问迭代器直接访问单个元素<br>3、deque提供了一些与vector相似的功能，但deque在头部和尾部进行数据插入和删除操作更加高效。与vector不同的是，deque不能保证所有元素都存储在连续的空间中，在deque中通过指针加偏移量的方式访问元素可能导致非法的操作</p>
<p>就我而言，其实，相比其他容器而言，deque比较“鸡肋”（个人观点），若要说遍历元素，用vector足以完成，若要说插入删除，list也够用，而且相比来说，deque性能在这两方面性能较差<br>  <img src="https://img-blog.csdnimg.cn/20191025194344163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="deque的接口"><a href="#deque的接口" class="headerlink" title="deque的接口"></a>deque的接口</h3><p>  <img src="https://img-blog.csdnimg.cn/20191025194441955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="deque的应用场景"><a href="#deque的应用场景" class="headerlink" title="deque的应用场景"></a>deque的应用场景</h3><p>deque在序列式容器中比较鸡肋，因为如果只是简单的存储元素，使用vector即可，如果对元素任意位置进行插入或者删除操作比较多，使用list即可，所以一般很少去使用deque，它最大的应用，就是作为标准库中stack和queue的底层结构<br>详见<a href="https://blog.csdn.net/qq_43746320/article/details/102749009">库函数stack的模拟实现</a>和<a href="https://blog.csdn.net/qq_43746320/article/details/102749043">库函数queue的模拟实现</a></p>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
