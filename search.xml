<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>list的模拟实现</title>
    <url>/2019/12/31/list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ListNode(<span class="keyword">const</span> T&amp; data = T())</span><br><span class="line">		:_pNext(<span class="literal">nullptr</span>)</span><br><span class="line">		, _pPrev(<span class="literal">nullptr</span>)</span><br><span class="line">		, _data(data)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* _pNext;</span><br><span class="line">	ListNode* _pPrev;</span><br><span class="line">	T _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">List_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> List_iterator&lt;T&gt; Self;</span><br><span class="line"></span><br><span class="line">	List_iterator(Node* pCur)</span><br><span class="line">		:_pCur(pCur)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _pCur-&gt;_data;</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(_pCur-&gt;_data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		_pCur = _pCur-&gt;_pNext;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_pCur = _pCur-&gt;_pNext;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		_pCur = _pCur-&gt;_pPrev;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_pCur = _pCur-&gt;_pPrev;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _pCur == l._pCur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _pCur != l._pCur;</span><br><span class="line">	&#125;</span><br><span class="line">	Node* _pCur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">List_reverse_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> List_reverse_iterator&lt;Iterator, T&gt; Self;</span><br><span class="line"></span><br><span class="line">	List_reverse_iterator(Iterator it)</span><br><span class="line">		:_it(it)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		Iterator temp = _it;</span><br><span class="line">		--temp;</span><br><span class="line">		<span class="keyword">return</span> *temp;</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		--_it;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_it--;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		++_it;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Self <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_it++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _it != l._it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _it == l._it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Iterator _it;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> List_iterator&lt;T&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> List_reverse_iterator&lt;iterator, T&gt; reverse_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	List()</span><br><span class="line">	&#123;</span><br><span class="line">		CreatHead();</span><br><span class="line">	&#125;</span><br><span class="line">	List(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; val = T())</span><br><span class="line">	&#123;</span><br><span class="line">		CreatHead();</span><br><span class="line">		<span class="keyword">if</span> (_pHead)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				Push_Back(val);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	List(<span class="keyword">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		CreatHead();</span><br><span class="line">		Node* pCur = l._pHead-&gt;_pNext;</span><br><span class="line">		<span class="keyword">while</span> (pCur != l._pHead)</span><br><span class="line">		&#123;</span><br><span class="line">			Push_Back(pCur-&gt;_data);</span><br><span class="line">			pCur = pCur-&gt;_pNext;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">List</span>(<span class="title">iterator</span> <span class="title">first</span>, <span class="title">iterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		CreatHead();</span><br><span class="line">		<span class="keyword">while</span> (first != last)</span><br><span class="line">		&#123;</span><br><span class="line">			Push_Back(*first);</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~List()</span><br><span class="line">	&#123;</span><br><span class="line">		clear();</span><br><span class="line">		<span class="keyword">delete</span> _pHead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	List&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//if (this != &amp;l)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	clear();</span></span><br><span class="line">		<span class="comment">//	Node* pCur = l._pHead-&gt;_pNext;</span></span><br><span class="line">		<span class="comment">//	while (pCur != l._pHead)</span></span><br><span class="line">		<span class="comment">//	&#123;</span></span><br><span class="line">		<span class="comment">//		Push_Back(pCur-&gt;_data);</span></span><br><span class="line">		<span class="comment">//		pCur = pCur-&gt;_pNext;</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		Swap(l);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> iterator(_pHead-&gt;_pNext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> iterator(_pHead);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> end();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> begin();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> Size()<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">		iterator it = begin();</span><br><span class="line">		<span class="keyword">while</span> (it != end())</span><br><span class="line">		&#123;</span><br><span class="line">			count++;</span><br><span class="line">			it++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pHead-&gt;_pNext == _pHead &amp;&amp; _pHead-&gt;_pPrev == _pHead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pHead-&gt;_pNext-&gt;_data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">front</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pHead-&gt;_pNext-&gt;_data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pHead-&gt;_pPrev-&gt;_data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">back</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _pHead-&gt;_pPrev-&gt;_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push_Back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Insert(end(), val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pop_Back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Earse(--end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push_Front</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Insert(begin(), val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pop_Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Earse(begin());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">Insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* pNewNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">		Node* pCur = pos._pCur;</span><br><span class="line"></span><br><span class="line">		pNewNode-&gt;_pPrev = pCur-&gt;_pPrev;</span><br><span class="line">		pNewNode-&gt;_pNext = pCur;</span><br><span class="line">		pCur-&gt;_pPrev-&gt;_pNext = pNewNode;</span><br><span class="line">		pCur-&gt;_pPrev = pNewNode;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> iterator(pNewNode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">Earse</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* pDelNode = pos._pCur;</span><br><span class="line">		<span class="keyword">if</span> (pDelNode == _pHead)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> end();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Node*  pRet = pDelNode-&gt;_pNext;</span><br><span class="line">		pDelNode-&gt;_pPrev-&gt;_pNext = pDelNode-&gt;_pNext;</span><br><span class="line">		pDelNode-&gt;_pNext-&gt;_pPrev = pDelNode-&gt;_pPrev;</span><br><span class="line">		<span class="keyword">delete</span> pDelNode;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> iterator(pRet);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* pCur = _pHead-&gt;_pNext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pCur != _pHead)</span><br><span class="line">		&#123;</span><br><span class="line">			_pHead-&gt;_pNext = pCur-&gt;_pNext;</span><br><span class="line">			<span class="keyword">delete</span> pCur;</span><br><span class="line">			pCur = _pHead-&gt;_pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		_pHead-&gt;_pNext = _pHead;</span><br><span class="line">		_pHead-&gt;_pNext = _pHead;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(List&lt;T&gt;&amp; l)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		swap(_pHead, l._pHead);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreatHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_pHead = <span class="keyword">new</span> Node;</span><br><span class="line">		_pHead-&gt;_pNext = _pHead;</span><br><span class="line">		_pHead-&gt;_pPrev = _pHead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _pHead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">const</span> <span class="title">List</span>&lt;T&gt;&amp; <span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != <span class="built_in">list</span>.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_print</span>(<span class="title">const</span> <span class="title">List</span>&lt;T&gt;&amp; <span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">auto</span> rit = <span class="built_in">list</span>.rbegin();</span><br><span class="line">	<span class="keyword">while</span> (rit != <span class="built_in">list</span>.rend())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		++rit;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestList1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;<span class="keyword">int</span>&gt; list1;</span><br><span class="line">	List&lt;<span class="keyword">int</span>&gt; list2(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	List&lt;<span class="keyword">int</span>&gt; list3(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">	List&lt;<span class="keyword">int</span>&gt; list4(list3);</span><br><span class="line"></span><br><span class="line">	print(list1);</span><br><span class="line">	print(list2);</span><br><span class="line">	print(list3);</span><br><span class="line">	reverse_print(list4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestList2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;<span class="built_in">string</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span>.Push_Back(<span class="string">"aaaa"</span>);</span><br><span class="line">	<span class="built_in">list</span>.Push_Back(<span class="string">"xxxx"</span>);</span><br><span class="line">	<span class="built_in">list</span>.Push_Back(<span class="string">"zzzz"</span>);</span><br><span class="line">	<span class="built_in">list</span>.Push_Back(<span class="string">"yyyy"</span>);</span><br><span class="line">	print(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>.Pop_Back();</span><br><span class="line">	<span class="built_in">list</span>.Pop_Back();</span><br><span class="line">	print(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>.Push_Front(<span class="string">"iiii"</span>);</span><br><span class="line">	<span class="built_in">list</span>.Push_Front(<span class="string">"lllll"</span>);</span><br><span class="line">	<span class="built_in">list</span>.Push_Front(<span class="string">"y"</span>);</span><br><span class="line">	<span class="built_in">list</span>.Push_Front(<span class="string">"!!!"</span>);</span><br><span class="line">	print(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>.Pop_Front();</span><br><span class="line">	print(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>.clear();</span><br><span class="line">	print(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" test over"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// TestList1();</span></span><br><span class="line">	TestList2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vector的模拟实现</title>
    <url>/2019/12/23/vector%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector的底层结构为可存放任意类型的动态顺序表</span></span><br><span class="line"><span class="comment">//由于可存放任意类型，所以用模板来进行模拟实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Vector的迭代器实际就是一个原生态指针</span></span><br><span class="line">	<span class="keyword">typedef</span> T* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//构造与析构函数</span></span><br><span class="line">	Vector()  <span class="comment">//无参构造函数</span></span><br><span class="line">		:_start(<span class="literal">nullptr</span>)</span><br><span class="line">		, _finish(<span class="literal">nullptr</span>)</span><br><span class="line">		, _endOfStorage(<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	Vector(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; val = T())  <span class="comment">//带参构造函数：用n个val填充</span></span><br><span class="line">		:_start(<span class="keyword">new</span> T[n])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			_start[i] = val;</span><br><span class="line">		&#125;</span><br><span class="line">		_finish = _start + n;</span><br><span class="line">		_endOfStorage = _finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v)  <span class="comment">//拷贝构造</span></span><br><span class="line">		:_start(<span class="literal">nullptr</span>)</span><br><span class="line">		, _finish(<span class="literal">nullptr</span>)</span><br><span class="line">		, _endOfStorage(<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//开辟空间，防止浅拷贝</span></span><br><span class="line">		Reserve(v.Capacity());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//拷贝元素</span></span><br><span class="line">		iterator it = begin();</span><br><span class="line">		const_iterator const_it = v.const_begin();</span><br><span class="line">		<span class="keyword">while</span> (const_it != v.const_end())</span><br><span class="line">		&#123;</span><br><span class="line">			*it++ = *const_it++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新指针的指向</span></span><br><span class="line">		_finish = _start + v.Size();</span><br><span class="line">		_endOfStorage = _start + v.Capacity();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果使用iterator做迭代器，会导致初始化的迭代器区间[first, last)只能是vector的迭代器</span></span><br><span class="line">	<span class="comment">//重新声明迭代器，迭代器区间[first, last)可以是任意容器的迭代器</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">Vector</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>)  //区间构造</span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		Reserve(last - first);</span><br><span class="line">		<span class="keyword">while</span> (first != last)</span><br><span class="line">		&#123;</span><br><span class="line">			Push_Back(*first);</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Vector()  <span class="comment">//析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_start)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] _start;</span><br><span class="line">			_start = <span class="literal">nullptr</span>;</span><br><span class="line">			_finish = <span class="literal">nullptr</span>;</span><br><span class="line">			_endOfStorage = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//迭代器</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反向迭代器</span></span><br><span class="line">	<span class="function">const_iterator <span class="title">const_begin</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">const_end</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//空间增长操作</span></span><br><span class="line">	<span class="keyword">size_t</span> Size()<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _finish - _start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> Capacity()<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _endOfStorage - _start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_start == _finish)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//空</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">(<span class="keyword">size_t</span> newSize, <span class="keyword">const</span> T&amp; val = T())</span>  <span class="comment">//重新规定空间中元素的个数，若规定后存在未装载元素的空间，用val填充</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//若新大小 小于 旧的大小，直接更新_finish，返回； 否则要对未装载元素的空间进行赋值</span></span><br><span class="line">		<span class="keyword">if</span> (newSize &lt; size())</span><br><span class="line">		&#123;</span><br><span class="line">			_finish = _start + newSize;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若新大小大于总容量，扩容</span></span><br><span class="line">		<span class="keyword">if</span> (newSize &gt; Capacity())</span><br><span class="line">		&#123;</span><br><span class="line">			Reserve(newSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//对未装载元素的空间赋值val</span></span><br><span class="line">		iterator it = _finish;  <span class="comment">//先用旧的尾作为新的遍历头</span></span><br><span class="line">		iterator _finish = _start + newSize;  <span class="comment">//再更新 新的尾，并且作为遍历的终点</span></span><br><span class="line">		<span class="keyword">while</span> (it != _finish)</span><br><span class="line">		&#123;</span><br><span class="line">			*it++ = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Reserve</span><span class="params">(<span class="keyword">size_t</span> newCapacity)</span>  <span class="comment">//扩容</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (newCapacity &gt; Capacity())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//-----1、开辟新空间</span></span><br><span class="line">			T* temp = <span class="keyword">new</span> T[newCapacity];</span><br><span class="line">			<span class="comment">//-----2、资源拷贝</span></span><br><span class="line">			<span class="keyword">size_t</span> n = Size();</span><br><span class="line">			<span class="keyword">if</span> (_start) <span class="comment">//如果_start指向的空间存在时</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">				&#123;</span><br><span class="line">					temp[i] = _start[i];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//-----3、释放旧空间</span></span><br><span class="line">				<span class="keyword">delete</span>[] _start;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//更新指针的指向</span></span><br><span class="line">			_start = temp;</span><br><span class="line">			_finish = _start + n;</span><br><span class="line">			_endOfStorage = _start + newCapacity;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			_finish = _start + newCapacity;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//增删查改</span></span><br><span class="line">	Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(Vector&lt;T&gt; v)</span><br><span class="line">	&#123;</span><br><span class="line">		Swap(v);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push_Back</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span>  <span class="comment">//尾插一个元素c</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Insert(end(), c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pop_Back</span><span class="params">()</span>  <span class="comment">//删掉最后一个元素</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		--_finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">Insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; c)</span>  <span class="comment">//插入一个元素，并返回其插入位置的地址</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//断言，看插入的位置是否合法</span></span><br><span class="line">		assert(pos &gt;= begin() &amp;&amp; pos &lt;= end());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否需要扩容</span></span><br><span class="line">		<span class="keyword">if</span> (_finish == _endOfStorage)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">size_t</span> size = Size();</span><br><span class="line">			<span class="keyword">size_t</span> newCapacity = (<span class="number">0</span> == Capacity()) ? <span class="number">1</span> : Capacity() * <span class="number">2</span>;</span><br><span class="line">			Reserve(newCapacity);</span><br><span class="line">			<span class="comment">//由于扩容引起的空间地址发生变化，导致需要重置pos</span></span><br><span class="line">			pos = _start + size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将pos位及以后的元素全部向后移动一位</span></span><br><span class="line">		iterator it = end();</span><br><span class="line">		<span class="keyword">while</span> (it &gt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			*it = *(it - <span class="number">1</span>);</span><br><span class="line">			--it;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//pos位插入c</span></span><br><span class="line">		*pos = c;</span><br><span class="line">		<span class="comment">//更新_finish</span></span><br><span class="line">		++_finish;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">Earse</span><span class="params">(iterator pos)</span>  <span class="comment">//删除pos位置的元素，返回删除位置</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//判断删除位置的合法性</span></span><br><span class="line">		assert(pos &gt;= begin() &amp;&amp; pos &lt; end());</span><br><span class="line"></span><br><span class="line">		iterator it = pos;</span><br><span class="line">		<span class="keyword">while</span> (it != end() - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*it = *(it + <span class="number">1</span>);</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">		--_finish;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(Vector&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		swap(_start, v._start);</span><br><span class="line">		swap(_finish, v._finish);</span><br><span class="line">		swap(_endOfStorage, v._endOfStorage);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos)</span><br><span class="line">	&#123;</span><br><span class="line">		assert(pos &lt; Size());</span><br><span class="line">		<span class="keyword">return</span> _start[pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert(pos &lt; Size());</span><br><span class="line">		<span class="keyword">return</span> _start[pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	iterator _start;  <span class="comment">//指向顺序表内第一个元素</span></span><br><span class="line">	iterator _finish;  <span class="comment">//指向顺序表内最后一个元素的末尾(下一个位置)</span></span><br><span class="line">	iterator _endOfStorage;  <span class="comment">//指向该空间中的末尾(最后一个位置)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestVector1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v2(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v3(v2.begin() + <span class="number">1</span>, v2.end());</span><br><span class="line">	Vector&lt;<span class="keyword">int</span>&gt; v4(v3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestVector2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.Size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.Capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	v.Push_Back(<span class="string">'a'</span>);</span><br><span class="line">	v.Push_Back(<span class="string">'b'</span>);</span><br><span class="line">	v.Push_Back(<span class="string">'c'</span>);</span><br><span class="line">	v.Push_Back(<span class="string">'d'</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.Size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.Capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	v.Pop_Back();</span><br><span class="line">	v.Pop_Back();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.Size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.Capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">TestVector3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	v.Push_Back(<span class="string">"1111"</span>);</span><br><span class="line">	v.Push_Back(<span class="string">"22222"</span>);</span><br><span class="line">	v.Push_Back(<span class="string">"333333"</span>);</span><br><span class="line">	v.Push_Back(<span class="string">"000"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.Size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// TestVector1();</span></span><br><span class="line">	<span class="comment">// TestVector2();</span></span><br><span class="line">	TestVector3();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL之string</title>
    <url>/2019/12/17/C++STL%E4%B9%8Bstring/</url>
    <content><![CDATA[<h3 id="了解string类"><a href="#了解string类" class="headerlink" title="了解string类"></a>了解string类</h3><p>1、string是表示字符串的字符串类<br>2、该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。<br>3、string在底层实际是：<br>basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt; string;<br>4、不能操作多字节或者变长字符的序列。</p>
<h3 id="常用接口说明"><a href="#常用接口说明" class="headerlink" title="常用接口说明"></a>常用接口说明</h3><p><a href="http://www.cplusplus.com/reference/string/string/?kw=string">string类的接口详解</a><br>下面，将会拣选各个功能中最常用的加以描述</p>
<h6 id="1、常见的构造函数"><a href="#1、常见的构造函数" class="headerlink" title="1、常见的构造函数"></a>1、常见的构造函数</h6><table>
<thead>
<tr>
<th>(constructor)函数名称</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>string()</td>
<td>构造空的string类对象，即空字符串</td>
</tr>
<tr>
<td>string(const char * s)</td>
<td>用C-string来构造string类对象</td>
</tr>
<tr>
<td>string(size_t n, char c)</td>
<td>string类对象中包含n个字符c</td>
</tr>
<tr>
<td>string(const string&amp;s)</td>
<td>拷贝构造函数</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20190926170121116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></td>
<td></td>
</tr>
<tr>
<td>###### 2、容量操作</td>
<td></td>
</tr>
<tr>
<td>函数名称</td>
<td>功能说明</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>size</td>
<td>返回字符串有效字符长度</td>
</tr>
<tr>
<td>length</td>
<td>返回字符串有效字符长度</td>
</tr>
<tr>
<td>capacity</td>
<td>返回空间总大小</td>
</tr>
<tr>
<td>empty</td>
<td>检测字符串释放为空串，是返回true，否则返回false</td>
</tr>
<tr>
<td>clear</td>
<td>清空有效字符</td>
</tr>
<tr>
<td>reserve</td>
<td>为字符串预留空间</td>
</tr>
<tr>
<td>resize</td>
<td>将有效字符的个数改为n个，多出的用字符填充</td>
</tr>
</tbody></table>
<blockquote>
<p>size_t size() const noexcept; —-Return length of string<br>size_t length() const noexcept; —-Return length of string<br>size_t max_size() const noexcept; —-Return maximum size of string<br>void resize (size_t n);<br>void resize (size_t n, char c); —-Resize string<br>size_t capacity() const noexcept; —-Return size of allocated storage<br>void reserve (size_t n = 0); —-Request a change in capacity<br>void clear() noexcept; —-Clear string<br>bool empty() const noexcept; —-Test if string is empty<br>void shrink_to_fit(); —-Shrink to fit</p>
</blockquote>
<p>【注意】<br>1、size()和length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都用size()<br>2、clear()只是将string中有效字符清空，不改变底层大小<br>3、reserve(size_t res_arg = 0)：为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserve不会改变容量大小</p>
<h6 id="3、访问及遍历操作"><a href="#3、访问及遍历操作" class="headerlink" title="3、访问及遍历操作"></a>3、访问及遍历操作</h6><table>
<thead>
<tr>
<th>函数名称</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>operator[]</td>
<td>返回pos位置的字符，const string类对象调用</td>
</tr>
<tr>
<td>begin+end</td>
<td>begin获取一个字符的迭代器+end获取最后一个字符下一位置的迭代器</td>
</tr>
<tr>
<td>rbegin+rend</td>
<td>rbegin获取一个字符的迭代器+rend获取最后一个字符下一位置的迭代器</td>
</tr>
<tr>
<td>范围for</td>
<td>C++11支持更简洁的范围for循环的新便利方式</td>
</tr>
</tbody></table>
<blockquote>
<p>   iterator begin() noexcept;<br>   const_iterator begin() const noexcept;  —-Return iterator to beginning<br>   iterator end() noexcept;<br>   const_iterator end() const noexcept; —-Return iterator to end<br>   reverse_iterator rbegin() noexcept;<br>   const_reverse_iterator rbegin() const noexcept; —-Return reverse iterator to reverse beginning<br>    reverse_iterator rend() noexcept;<br>    const_reverse_iterator rend() const noexcept; —-Return reverse iterator to reverse end<br>     char&amp; operator[] (size_t pos);<br>     const char&amp; operator[] (size_t pos) const; —-Get character of string<br>      char&amp; at (size_t pos);<br>      const char&amp; at (size_t pos) const; —-Get character in string</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种遍历方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> e : s)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// C++98</span></span><br><span class="line">	<span class="comment">//string::iterator it = s.begin();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	<span class="keyword">auto</span> it = s.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != s.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4、修改操作"><a href="#4、修改操作" class="headerlink" title="4、修改操作"></a>4、修改操作</h6><table>
<thead>
<tr>
<th>函数名称</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>push_back</td>
<td>在字符串后尾插字符</td>
</tr>
<tr>
<td>append</td>
<td>在字符串后追加一个字符串</td>
</tr>
<tr>
<td>operator+=</td>
<td>在字符串后追加字符串</td>
</tr>
<tr>
<td>c_str</td>
<td>返回C格式字符串</td>
</tr>
<tr>
<td>find+npos</td>
<td>从字符串pos位置开始往后找某字符，返回该字符在字符串中的位置</td>
</tr>
<tr>
<td>rfind</td>
<td>从字符串pos位置开始往前找某字符，返回该字符在字符串中的位置</td>
</tr>
<tr>
<td>substr</td>
<td>在字符串中从pos位置开始，截取n个字符，返回</td>
</tr>
</tbody></table>
<blockquote>
<p>void push_back (char c); —-Append character to string</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190926174517407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926174607589.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926174631281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926174650979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926174712592.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926174733226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>void swap (string&amp; str); —-Swap string values<br>void pop_back(); —-Delete last character</p>
<p>const char* c_str() const noexcept;  —-Get C string equivalent<br>const char* data() const noexcept; —-Get string data<br>size_t copy (char* s, size_t len, size_t pos = 0) const; —-Copy sequence of characters from string<br>string substr (size_t pos = 0, size_t len = npos) const; —-Generate substring</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190926175134453.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926175206940.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926175233129.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926175259433.png" alt="在这里插入图片描述"><br>【注意】<br>1、在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += ‘c’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串<br>2、 对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好</p>
<h6 id="5、非成员函数"><a href="#5、非成员函数" class="headerlink" title="5、非成员函数"></a>5、非成员函数</h6><table>
<thead>
<tr>
<th>函数名称</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>operator+</td>
<td>建议尽量少用，因为传值返回，导致深拷贝效率低</td>
</tr>
<tr>
<td>operator&gt;&gt;</td>
<td>输入运算符重载</td>
</tr>
<tr>
<td>operator&gt;&gt;</td>
<td>输出运算符重载</td>
</tr>
<tr>
<td>getline</td>
<td>获取一行字符串</td>
</tr>
<tr>
<td>relational operators</td>
<td>大小比较的重载</td>
</tr>
</tbody></table>
<blockquote>
<p>void swap (string&amp; x, string&amp; y); —-Exchanges the values of two strings<br>istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str); —-Extract string from stream<br>ostream&amp; operator&lt;&lt; (ostream&amp; os, const string&amp; str); —-Insert string into stream</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/201909261753430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926175401629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190926175540135.png" alt="在这里插入图片描述"><br><a href="https://blog.csdn.net/qq_43746320/article/details/101485226">对于string类提供的方法的简单应用</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板(二)</title>
    <url>/2019/12/04/C++%E6%A8%A1%E6%9D%BF(%E4%BA%8C)/</url>
    <content><![CDATA[<p>在之前，我们简单的介绍了一下模板的运用，下面，将进一步的介绍模板运用过程中的几种形式以及可能出现的问题：</p>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>模板参数可以分为类型形参和非类型形参<br><strong>类型形参</strong>：出现在模板参数列表中，跟在class或者typename之后的参数类型名称<br><strong>非类型形参</strong>，就是用一个常量作为类（函数）模板的一个参数，在类（函数）模板中可<strong>将该参数当成常量来使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义一个模板类型的静态数组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span> = 10&gt;  //非类型模板参数<span class="title">N</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//插入元素，尾插</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		arr[size++] = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下标运算符重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="comment">//断言下标位置的合法性</span></span><br><span class="line">		assert(index &lt; size);</span><br><span class="line">		<span class="keyword">return</span> arr[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求大小</span></span><br><span class="line">	<span class="keyword">size_t</span> size()<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T arr[N];  <span class="comment">//T类型的静态数组</span></span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	arr.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要<strong>注意</strong>的是：<br>1、浮点数、类对象以及字符串是不允许作为非类型模板参数的<br>2、非类型的模板参数必须在编译期就能确认结果</p>
<h3 id="模板的特化"><a href="#模板的特化" class="headerlink" title="模板的特化"></a>模板的特化</h3><p>通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到错误的结果。例如，char* 类型(string)类就可能导致浅拷贝问题，导致内存被重复释放，以及内存泄漏等的问题<br>为了避免这些情况的发生，就需要对模板进行特化。即：在原模板类的基础上，针对特殊类型所进行特殊化的实现方式。模板特化分为函数模板特化和类模板特化</p>
<h5 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h5><p><strong>步骤：</strong><br>1、必须有一个基础的函数模板<br>2、template后的&lt;&gt;内没有参数，为空<br>3、函数名后跟&lt;&gt;，尖括号中指定需要特化的类型<br>4、函数参数表：必须要和模板函数的基础参数类型完全相同，如果不同，编译器可能会报一些奇怪的错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">Max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">char</span> *&gt;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">Max</span><span class="params">(<span class="keyword">char</span>*&amp; a, <span class="keyword">char</span>*&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;、、、&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：一般情况下如果函数模板遇到不能处理或处理有误的类型，为了实现简单，通常都是将该函数直接给出</strong></p>
<h5 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h5><h6 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h6><p>全特化是将模板参数类表中的所有的参数都确定化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&lt;int, char&gt;</span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h6><p>偏特化是任何针对模板参数进一步进行条件限制设计的特化版本<br>偏特化有两种表现方式：<br>1、部分特化：将模板参数类表中的一部分参数特化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br><span class="line"><span class="comment">//部分特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;T1, <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br></pre></td></tr></table></figure>

<p>2、参数更进一步的限制：针对模板参数更进一步的条件限制设计的特化版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br><span class="line"><span class="comment">//两个参数偏特化为指针类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&lt;T1*, T2*&gt;</span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br><span class="line"><span class="comment">//两个参数偏特化为引用类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&lt;T1&amp;, T2&amp;&gt;</span></span><br><span class="line"><span class="class">&#123;</span>、、、&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类模板特化应用值类型萃取"><a href="#类模板特化应用值类型萃取" class="headerlink" title="类模板特化应用值类型萃取"></a>类模板特化应用值类型萃取</h3><p>问题：如何实现一个通用的拷贝函数？</p>
<p>思路一：使用memcpy拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">copy</span>(<span class="title">T</span>* <span class="title">des</span>, <span class="title">const</span> <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(des, src, <span class="keyword">sizeof</span>(T)*size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：<strong>memcpy对任意类型的空间中内容都可以进行拷贝</strong>，且对于内置类型的拷贝效率很高，但是，这样就不可避免的涉及到<strong>深浅拷贝的问题</strong>（当拷贝一个指向已开辟空间的指针时，拷贝指针空间中的内容—-该片空间的起始地址，使得多个指针指向同一片空间释放时多次释放，且可能存在内存泄漏等的问题），所以<strong>memcpy属于浅拷贝</strong>，如果对象中涉及到<strong>资源管理</strong>，显然memcpy行不通</p>
<p>思路二：使用赋值方式拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">copy</span>(<span class="title">T</span>* <span class="title">des</span>, <span class="title">const</span> <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        des[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：循环赋值的方式可以实现拷贝，但若是内置类型也用这种方式进行拷贝，效率未免太低，所以单纯的循环赋值也不推荐</p>
<p>对两种思路比较：<br>1、memcpy对内置类型效率高，但会引起浅拷贝<br>2、循环赋值可以对所有类型的拷贝都适用，但相比memcpy对内置类型的效率未免有点低。</p>
<p>那么，能不能有一种方式将内置类型和自定义类型区分开来，内置类型用memcpy，自定义类型用循环赋值，这样效率会大大提升。下面，就引出了类型萃取</p>
<h6 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h6><p>&lt; 区分内置类型和自定义类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内置类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrueType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">struct <span class="keyword">bool</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FalseType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">struct <span class="keyword">bool</span> <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 给出模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">TypeTraits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Typedef FalseType ISPODType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 对TypeTraits类模板的实例化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;char&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Typedef TrueType ISPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;short&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Typedef TrueType ISPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;int&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Typedef TrueType ISPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;long&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Typedef TrueType ISPODType;</span><br><span class="line">&#125;;</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure>
<p>&lt; 通过对TypeTraits类的实例化，调用get()方法便可确认T的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">copy</span>(<span class="title">T</span>* <span class="title">des</span>, <span class="title">const</span> <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(TypeTraits&lt;T&gt;::ISPODType::Get())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(des, src, <span class="keyword">sizeof</span>(T)*size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            des[i] = src[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板分离编译"><a href="#模板分离编译" class="headerlink" title="模板分离编译"></a>模板分离编译</h3><h6 id="分离编译："><a href="#分离编译：" class="headerlink" title="分离编译："></a>分离编译：</h6><p>一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来形成单一的可执行文件的过程称为分离编译模式</p>
<h6 id="模板的分离编译："><a href="#模板的分离编译：" class="headerlink" title="模板的分离编译："></a>模板的分离编译：</h6><p>若在一个程序（项目）中，模板的声明与定义分离开，在头文件中进行声明，源文件中完成定义，在链接时就会报错</p>
<p>分析：<br><img src="https://img-blog.csdnimg.cn/20191027135724641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>C/C++程序要运行，一般经过：预处理—-&gt;编译—-&gt;汇编—-&gt;链接<br>&nbsp;&nbsp;&nbsp;&nbsp;编译：对程序按照语言特性进行词法，语法，语义分析，错误检查无误后生成汇编代码，期间头文件不参与编译，编译器对工程中的多个源文件是分离开单独编译的<br>&nbsp;&nbsp;&nbsp;&nbsp;链接：将多个.obj文件合并成一个，并处理没有解决的地址问题<br>在源文件的定义中，编译器并没有看到对模板函数的实例化，因此不会生成具体的函数<br>在编译后的obj文件中调用函数，编译器在链接时才会找函数的地址，但是函数没有实例化没有生成具体的代码，因此链接时报错</p>
<p>解决办法：<br>1、将声明和定义放到一个文件中，以避免这种报错，这种方法值得推荐<br>2、模板定义的位置显式实例化，这就意味着每一次使用函数模板就需要对它在声明的文件中进行实例化，或者在报错之后根据错误进行排查，很显然，这种方法并不实用</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>模板优点：<br>1、模板复用代码，节省资源，更快的迭代开发，C++的标准模板库因此产生<br>2、增强了代码的灵活性<br>模板缺陷：<br>1、模板会导致代码膨胀问题，也会导致编译时间变长<br>2、出现模板编译错误时，错误信息非常凌乱，不容易定位错误</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板</title>
    <url>/2019/11/27/C++%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p>如何实现一个通用的函数呢？<br>虽然使用函数重载可以实现，但是缺点很明显：<br>1、重载函数仅仅只是类型不同，代码复用率低，只要有新类型出现，就需要增加新的函数<br>2、代码可维护性低，一个出错可能所有的重载都出错<br>由此，引入了泛型编程的概念！</p>
<h6 id="泛型编程："><a href="#泛型编程：" class="headerlink" title="泛型编程："></a>泛型编程：</h6><p>编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。其中，模板包含函数模板和类模板</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本</p>
<h6 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h6><blockquote>
<p>template &lt; typename T1, typename T2, … , typename Tn &gt;<br>返回值类型 函数名 （参数列表）{ }</p>
</blockquote>
<p>【注意】typename是用来定义模板参数的关键字，也可以使用class(不能用struct代替class)</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器。</p>
<p>在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成的对应类型的函数以供调用。<br>如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。</p>
<h6 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h6><p>用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化。<br>1、隐式实例化：让编译器根据实参推演模板参数的实际类型</p>
<p>2、显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;       // 模板参数列表</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">left</span>, <span class="title">T</span> <span class="title">right</span>)  // 参数列表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 对函数模板进行实例化</span></span><br><span class="line">	<span class="comment">// 在编译阶段，如果编译器检测到对某个函数模板进行了实例化</span></span><br><span class="line">	<span class="comment">// 对实参的类型进行推演，根据推演的结果，确认模板参数列表中T的实际类型</span></span><br><span class="line">	<span class="comment">// 结合函数模板生成处理具体类型的函数</span></span><br><span class="line">	<span class="comment">// 隐式实例化</span></span><br><span class="line">	Add(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// int, int--T==&gt;int 生成intAdd函数---&gt;Add&lt;int&gt;</span></span><br><span class="line">	Add(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">//double, double--&gt; T==&gt;double 生成double Add函数---&gt;Add&lt;double&gt;</span></span><br><span class="line">	Add(<span class="string">'1'</span>, <span class="string">'2'</span>); <span class="comment">//char char--&gt;T==char 生成char Add函数---&gt;Add&lt;char&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 模板参数一般不会进行类型转化</span></span><br><span class="line">	<span class="comment">//Add(1, 2.0);   // int double--&gt; T</span></span><br><span class="line">	Add(<span class="number">1</span>, (<span class="keyword">int</span>)<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显式实例化---直接指定参数T的实际类型</span></span><br><span class="line">	<span class="comment">// 编译器：可能会进隐式类型转化</span></span><br><span class="line">	Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="模板参数的匹配原则"><a href="#模板参数的匹配原则" class="headerlink" title="模板参数的匹配原则"></a>模板参数的匹配原则</h6><p>1、一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数<br>2、对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个更好匹配的函数，那么将选择模板<br>3、函数模板不允许使用自动类型转换，单普通函数可以进行自动类型转换</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h6 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h6><blockquote>
<p>template &lt;class T1, class T2, … , class Tn&gt;<br>class 类模板名<br>{<br>    //类内成员定义<br>};</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态类型顺序表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SeqList(<span class="keyword">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">		: _array(<span class="keyword">new</span> T[capacity])</span><br><span class="line">		, _size(<span class="number">0</span>)</span><br><span class="line">		, _capacity(capacity)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~SeqList()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_array)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] _array;</span><br><span class="line">			_array = <span class="literal">nullptr</span>;</span><br><span class="line">			_capacity = <span class="number">0</span>;</span><br><span class="line">			_size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尾部</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		--_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 任意位置插入和删除</span></span><br><span class="line">	<span class="comment">//void Insert(size_t pos, const T&amp; data);</span></span><br><span class="line">	<span class="comment">//void Erase(size_t pos);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在const类型成员函数中不能修改成员变量</span></span><br><span class="line">	<span class="comment">// 修饰this指针</span></span><br><span class="line">	<span class="keyword">size_t</span> size()<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> Capacity()<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> == _size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		assert(index &lt; _size);</span><br><span class="line">		<span class="keyword">return</span> _array[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> index)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert(index &lt; _size);</span><br><span class="line">		<span class="keyword">return</span> _array[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">void</span> _CheckCapacity()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 开辟新空间</span></span><br><span class="line">			T* <span class="built_in">array</span> = <span class="keyword">new</span> T[<span class="number">2</span> * _capacity];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 拷贝元素</span></span><br><span class="line">			<span class="comment">// memcpy(array, _array, _size*sizeof(T));</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">array</span>[i] = _array[i];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 释放旧空间</span></span><br><span class="line">			<span class="keyword">delete</span>[] _array;</span><br><span class="line">			_array = <span class="built_in">array</span>;</span><br><span class="line">			_capacity *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* _array;</span><br><span class="line">	<span class="keyword">size_t</span> _size;</span><br><span class="line">	<span class="keyword">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:PushBack(<span class="keyword">const</span> T&amp; data)</span><br><span class="line">&#123;</span><br><span class="line">	_CheckCapacity();</span><br><span class="line">	_array[_size++] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSeqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SeqList&lt;<span class="keyword">int</span>&gt;  s1;</span><br><span class="line">	s1.PushBack(<span class="number">1</span>);</span><br><span class="line">	s1.PushBack(<span class="number">2</span>);</span><br><span class="line">	s1.PushBack(<span class="number">3</span>);</span><br><span class="line">	s1.PushBack(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s1.Capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	s1[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> SeqList&lt;<span class="keyword">double</span>&gt;  s2;</span><br><span class="line">	s2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TestSeqList();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h6><p>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。</p>
<hr>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板</title>
    <url>/2019/11/27/string%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">char</span>* iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">""</span>) <span class="comment">//构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">		_capacity = _size;</span><br><span class="line">		_str = <span class="keyword">new</span> <span class="keyword">char</span>[_capacity + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(_str, str);</span><br><span class="line">	&#125;</span><br><span class="line">	String(<span class="keyword">const</span> String&amp; str)  <span class="comment">//拷贝构造函数</span></span><br><span class="line">		:_str(<span class="literal">nullptr</span>)</span><br><span class="line">		, _capacity(<span class="number">0</span>)</span><br><span class="line">		, _size(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">String <span class="title">tmp</span><span class="params">(str._str)</span></span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Swap(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//string(const string&amp; s)</span></span><br><span class="line">	<span class="comment">//	: _size(s._size)</span></span><br><span class="line">	<span class="comment">//	, _capacity(s._size)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	_str = new char[_capacity + 1];</span></span><br><span class="line">	<span class="comment">//	strcpy(_str, s._str);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	~String()  <span class="comment">//析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_str)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] _str;</span><br><span class="line">			_str = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(String str)  <span class="comment">//赋值运算符重载 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Swap(str);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span>  <span class="comment">//迭代器</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _str + _size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//元素修改方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">char</span> c)</span>  <span class="comment">//尾插一个字符c</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			Reserve(_capacity * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		_str[_size++] = c;</span><br><span class="line">		_str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String&amp; <span class="keyword">operator</span>+=(<span class="keyword">char</span> c)  <span class="comment">//尾插一个字符</span></span><br><span class="line">	&#123;</span><br><span class="line">		PushBack(c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span>  <span class="comment">//尾接一个字符串</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((_size + <span class="built_in">strlen</span>(str)) &gt;= _capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			Reserve(_capacity + <span class="built_in">strlen</span>(str));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcat</span>(_str, str);</span><br><span class="line">		_size += <span class="built_in">strlen</span>(str);</span><br><span class="line">		_str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str)  <span class="comment">//尾接一个字符串</span></span><br><span class="line">	&#123;</span><br><span class="line">		Append(str);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span>  <span class="comment">//清空</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_size = <span class="number">0</span>;</span><br><span class="line">		_str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(String&amp; str)</span>  <span class="comment">//交换对象中的资源</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		swap(_str, str._str);</span><br><span class="line">		swap(_capacity, str._capacity);</span><br><span class="line">		swap(_size, str._size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">C_Str</span><span class="params">()</span><span class="keyword">const</span>  <span class="comment">//用C风格字符串表示</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _str;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">String&amp; <span class="title">Reserve</span><span class="params">(<span class="keyword">size_t</span> newCapacity)</span>  <span class="comment">//扩容</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (newCapacity &gt; _capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[newCapacity + <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(str, _str);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span>[] _str;</span><br><span class="line">			_str = str;</span><br><span class="line">			_capacity = newCapacity;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">String&amp; <span class="title">Resize</span><span class="params">(<span class="keyword">size_t</span> newSize, <span class="keyword">char</span> c = <span class="string">'\0'</span>)</span>  <span class="comment">//改变大小，多的空间位用字符c填充</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (newSize &gt; _size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (newSize &gt; _capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				Reserve(newSize);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memset</span>(_str + _size, c, newSize - _size);</span><br><span class="line">		&#125;</span><br><span class="line">		_size = newSize;</span><br><span class="line">		_str[newSize] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标访问运算符重载的方法通常成对出现，一般方法和const方法</span></span><br><span class="line">	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> index)  <span class="comment">//下标访问运算符重载</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert(index &lt; _size);</span><br><span class="line">		<span class="keyword">return</span> _str[_size];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> index)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		assert(index &lt; _size);</span><br><span class="line">		<span class="keyword">return</span> _str[_size];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断运算符重载</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(_str, s._str) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(_str, s._str) &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(_str, s._str) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(_str, s._str) &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(_str, s._str) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(*<span class="keyword">this</span> == s))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//元素修改方法</span></span><br><span class="line">	<span class="keyword">size_t</span> Find(<span class="keyword">char</span> c, <span class="keyword">size_t</span> pos = <span class="number">0</span>)<span class="keyword">const</span> <span class="comment">//返回c在string中第一次出现的位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = pos; i &lt; _size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (_str[i] == c)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> Find(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = <span class="number">0</span>)<span class="keyword">const</span> <span class="comment">//返回子串s在string中第一次出现的位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		assert(s != nullptr);</span></span><br><span class="line"><span class="comment">		char* str = strstr(_str, s);</span></span><br><span class="line"><span class="comment">		if (str != nullptr)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			return str - s;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = pos; i &lt; _size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (_str[i + j] != s[j])  <span class="comment">//子串遍历中，若有一位的元素未能匹配成功，本次匹配失败，跳出，为下一次匹配做准备</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">1</span>)  <span class="comment">//经过遍历子串s，子串每一个元素都与目标串相同，直接返回即可</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="number">1</span>;  <span class="comment">//本次未能匹配成功，下一次匹配前必须将标志位置为1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">String&amp; <span class="title">Insert</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">char</span> c)</span> <span class="comment">//在pos位插入字符c</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			Reserve(_capacity * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = _size; i &gt; pos; --i) <span class="comment">//从结束符'\0'位置开始后移一个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			_str[i] = _str[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		_str[pos] = c;</span><br><span class="line">		_str[++_size] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">String&amp; <span class="title">Insert</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span> <span class="comment">//在pos位插入字符串str</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">		<span class="keyword">if</span> (_size + len &gt; _capacity) <span class="comment">//看是否需要扩容</span></span><br><span class="line">		&#123;</span><br><span class="line">			Reserve(_size + len);</span><br><span class="line">			_size = _size + len;  <span class="comment">//更新_size值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = _size; i &gt;= pos + len; --i) <span class="comment">//从结束符'\0'位置(_str[_size]位置)开始后移len位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			_str[i] = _str[i - len];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = pos, j = <span class="number">0</span>; j &lt; len; ++i, ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			_str[i] = str[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">String&amp; <span class="title">Erase</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> len)</span> <span class="comment">//删除pos位置的元素</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = pos; i &lt; _size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			_str[i] = _str[i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		_size--;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* _str;  <span class="comment">//字符串</span></span><br><span class="line">	<span class="keyword">size_t</span> _capacity;  <span class="comment">//容量</span></span><br><span class="line">	<span class="keyword">size_t</span> _size;  <span class="comment">//字符串大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String s1;</span><br><span class="line">	<span class="function">String <span class="title">s2</span><span class="params">(<span class="string">"helloWorld"</span>)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">s4</span><span class="params">(<span class="string">"school"</span>)</span></span>;</span><br><span class="line">	s1 = s4;</span><br><span class="line">	s2.PushBack(<span class="string">'!'</span>);</span><br><span class="line">	s3 += <span class="string">'!'</span>;</span><br><span class="line">	s3 += <span class="string">" great!"</span>;</span><br><span class="line">	s4.Append(<span class="string">" great"</span>);</span><br><span class="line">	s1.Clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">(<span class="string">"abcdefabdmn"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">size_t</span> res = s1.Find(<span class="string">'a'</span>);</span><br><span class="line">	res = s1.Find(<span class="string">'a'</span>, <span class="number">3</span>);</span><br><span class="line">	res = s1.Find(<span class="string">"abd"</span>);</span><br><span class="line">	res = s1.Find(<span class="string">"mn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestString3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">(<span class="string">"abcdefabdmn"</span>)</span></span>;</span><br><span class="line">	s1.Insert(<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">	s1.Insert(<span class="number">3</span>, <span class="string">'a'</span>);</span><br><span class="line">	s1.Insert(<span class="number">1</span>, <span class="string">"abcd"</span>);</span><br><span class="line">	s1.Insert(<span class="number">3</span>, <span class="string">"xzy"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//TestString1();</span></span><br><span class="line">	<span class="comment">//TestString2();</span></span><br><span class="line">	TestString3();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内存管理</title>
    <url>/2019/11/21/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="C-C-内存分布"><a href="#C-C-内存分布" class="headerlink" title="C/C++内存分布"></a>C/C++内存分布</h1><p><img src="https://img-blog.csdnimg.cn/2019092322493418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><p>1、栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的<br>2、内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可以使用系统接口创建共享内存，做进程间通信<br>3、堆用于程序运行时动态内存分配 ，堆是向上增长的<br>4、数据段—-存储全局数据和静态数据<br>5、代码段—-可执行的代码/只读常量</p>
<h1 id="C中动态内存管理"><a href="#C中动态内存管理" class="headerlink" title="C中动态内存管理"></a>C中动态内存管理</h1><h3 id="malloc-calloc-realloc-free"><a href="#malloc-calloc-realloc-free" class="headerlink" title="malloc/calloc/realloc/free"></a>malloc/calloc/realloc/free</h3><blockquote>
<p>void* malloc (size_t size);<br>【分配内存块】<br>分配一块内存大小为size的块，并返回一个指向该块开头的指针。<br>新分配的内存块的内容未初始化，剩余的值不确定。<br>如果size为零，则返回值取决于特定的库实现（它可以是null指针，也可以不是null指针），但是不得取消对返回的指针的引用。</p>
</blockquote>
<blockquote>
<p>void* calloc (size_t num, size_t size);<br>【分配和零初始化内存块】<br>num—&gt;要分配的元素数；  size—&gt;每个元素的大小<br>为一个num元素数组分配一个内存块，每个元素的大小为字节长，并将其所有位初始化为零。<br>有效的结果是分配了一个零初始化的(num*size)字节存储块。<br>如果size为零，则返回值取决于特定的库实现（它可以是null指针，也可以不是null指针），但是不得取消对返回的指针的引用。</p>
</blockquote>
<blockquote>
<p>void* realloc (void* ptr, size_t size);<br>【重新分配内存块】<br>更改ptr指向的内存块的大小。<br>若ptr指向为之前开辟的一片空间，那么若num小于等于原空间的大小，只会将原空间后面多出的部分舍弃，返回原空间的首地址即可。<br>若num大于原空间的大小，且若在原空间后面开辟空间的话，会影响其他空间的内容，该函数会将存储块移动到一个新的位置，并返回新位置的地址。<br>即使将存储块移动到新位置，该存储块的内容也会保留到新旧大小中的较小者。如果新的大小越大，则新分配的部分的值是不确定的。<br>在这种情况下ptr为空指针，该函数的行为像的malloc，分配一个新的大小为字节的块，并返回一个指向其开头的指针。</p>
</blockquote>
<blockquote>
<p>void free (void* ptr);<br>【解除分配内存块】<br>先前经malloc/calloc/realloc调用分配的一块内存会被释放，使其再次可用于进一步分配。<br>如果ptr不指向分配有上述功能的内存块，则会导致未定义的行为。<br>如果ptr是空指针，则该函数不执行任何操作。<br>【注意】此函数不会更改ptr本身的值，因此它仍指向相同（现在无效）的位置。</p>
</blockquote>
<h3 id="VS下malloc的底层结构"><a href="#VS下malloc的底层结构" class="headerlink" title="VS下malloc的底层结构"></a>VS下malloc的底层结构</h3><p><img src="https://img-blog.csdnimg.cn/20190924120836143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由此可知，malloc有额外的空间浪费</p>
<h1 id="C-中动态内存管理"><a href="#C-中动态内存管理" class="headerlink" title="C++中动态内存管理"></a>C++中动态内存管理</h1><p>C语言内存管理方式在C++中可以继续使用，但是有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：<strong>通过new和delete操作符进行动态内存管理</strong></p>
<h3 id="new-delete操作内置类型"><a href="#new-delete操作内置类型" class="headerlink" title="new/delete操作内置类型"></a>new/delete操作内置类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//动态申请一个int类型的空间</span></span><br><span class="line">	<span class="keyword">int</span> * ptr1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	<span class="comment">//动态申请一个int类型的空间，并初始化为10</span></span><br><span class="line">	<span class="keyword">int</span> * ptr2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//动态申请10个连续的int类型的空间</span></span><br><span class="line">	<span class="keyword">int</span> * ptr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="comment">//动态申请10个连续的int类型空间，并都初始化为1</span></span><br><span class="line">	<span class="keyword">int</span> * ptr4 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">delete</span> ptr1;</span><br><span class="line">	<span class="keyword">delete</span> ptr2;</span><br><span class="line">	<span class="keyword">delete</span>[] ptr3;</span><br><span class="line">	<span class="keyword">delete</span>[] ptr4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】<br>申请和释放单个元素的空间，使用new和delete操作符； 申请和释放连续的空间，使用new[]和delete[]</p>
<h3 id="new和delete操作自定义类型"><a href="#new和delete操作自定义类型" class="headerlink" title="new和delete操作自定义类型"></a>new和delete操作自定义类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test()</span><br><span class="line">		: _data(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test(): "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Test(): "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//申请单个Test类型的空间</span></span><br><span class="line">	Test * p1 = (Test *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Test));</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	<span class="comment">//申请10个Test类型的空间</span></span><br><span class="line">	Test * p2 = (Test *) <span class="built_in">malloc</span> (<span class="number">10</span> * <span class="keyword">sizeof</span>(Test));</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//申请单个Test类型的对象</span></span><br><span class="line">	Test * p1 = <span class="keyword">new</span> Test;</span><br><span class="line">	<span class="keyword">delete</span> p1;</span><br><span class="line">	<span class="comment">//申请10个Test类型的对象</span></span><br><span class="line">	Test * p2 = <span class="keyword">new</span> Test[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】<br>在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc和free不会，申请和释放的只是一块大小与对象相同的内存空间<br>malloc/free 和 new/delete都是成对存在的，需要匹配使用。若未匹配使用，对于内置类型无影响，但对于自定义类型，只要涉及到连续申请释放，程序必然会崩溃</p>
<h3 id="operator-new和operator-delete"><a href="#operator-new和operator-delete" class="headerlink" title="operator new和operator delete"></a>operator new和operator delete</h3><p>new和delete是用户进行动态内存申请和释放的操作符<br>operator new和operator delete是系统提供的全局函数<br>new在底层调用operator new来申请空间，delete在底层通过operator delete来释放空间</p>
<p>operator new: 该函数实际通过malloc来申请空间，当malloc申请成功时直接返回；申请空间失败，抛出异常，除非用户设置了空间不足应对措施<br>operator delete：该函数最终是是通过free来释放空间的</p>
<h3 id="new-和-delete实现原理"><a href="#new-和-delete实现原理" class="headerlink" title="new 和 delete实现原理"></a>new 和 delete实现原理</h3><h6 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h6><p>如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请和释放的是连续空间，而且new在申请空间失败时会抛出异常。malloc则会返回NULL</p>
<h6 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h6><p><strong>new</strong><br>1、调用operator new函数申请空间<br>2、在申请空间上执行构造函数，完成对象的构造<br><strong>delete</strong><br>1、在空间上执行析构函数，完成对象中资源的清理工作<br>2、调用operator delete函数释放对象的空间<br><strong>new T[N]</strong><br>1、调用operator new[] 函数，在operator new[]中实际调用operator new函数完成N-1个对象空间的申请<br>2、在申请的空间上执行N次构造函数<br><strong>delete[]</strong><br>1、在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理<br>2、调用 operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间</p>
<h3 id="定位new表达式（placement-new）"><a href="#定位new表达式（placement-new）" class="headerlink" title="定位new表达式（placement-new）"></a>定位new表达式（placement-new）</h3><p>定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象</p>
<p>使用格式：<br>new (place_address) type 或者 new (place_address) type (initializer-list)<br>place_address必须是一个指针，initializer-list 是类型的初始化列表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// placement-new</span></span><br><span class="line"><span class="comment">// 定位new表达式：在已经存在的空间上执行构造函数</span></span><br><span class="line"><span class="comment">// 语法： new(地址) Test(参数);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test(<span class="keyword">int</span> data)</span><br><span class="line">	&#123;</span><br><span class="line">		_data = <span class="number">10</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test():"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Test()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Test():"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用来申请空间的new操作符---C++提供的关键字---专门用来申请空间</span></span><br><span class="line"><span class="comment">    1. 调用void* operator new(size_t size)</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">	          // 调用malloc循环申请 + 空间不足应对措施</span></span><br><span class="line"><span class="comment">	      &#125;</span></span><br><span class="line"><span class="comment">    2. 调用构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> void* operator new(size_t size)是一个函数，一般情况下不需要自己给出,除非需要定制特殊功能</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定位new表达式：</span></span><br><span class="line"><span class="comment">  new(p) T</span></span><br><span class="line"><span class="comment">    1. void* operator new(size_t size, void* where)</span></span><br><span class="line"><span class="comment">	   &#123;</span></span><br><span class="line"><span class="comment">	        return where;</span></span><br><span class="line"><span class="comment">	   &#125;</span></span><br><span class="line"><span class="comment">	2. 执行构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test* pt = (Test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Test));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只需在pt指向的空间上执行构造函数</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	定位new表达式：调用operator new</span></span><br><span class="line"><span class="comment">	void* operator new(size_t size, void* where)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	     return where;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">new</span>(pt) Test(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//delete pt;</span></span><br><span class="line">	pt-&gt;~Test();</span><br><span class="line">	<span class="built_in">free</span>(pt);</span><br><span class="line">	<span class="comment">// 需要将pt指向的空间当成对象来用</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="malloc-free-amp-amp-new-delete"><a href="#malloc-free-amp-amp-new-delete" class="headerlink" title="malloc/free &amp;&amp; new/delete"></a>malloc/free &amp;&amp; new/delete</h1><h3 id="同："><a href="#同：" class="headerlink" title="同："></a>同：</h3><p>都是从堆上申请空间，并且需要用户手动释放</p>
<h3 id="异："><a href="#异：" class="headerlink" title="异："></a>异：</h3><table>
<thead>
<tr>
<th>malloc/free</th>
<th>new/delete</th>
</tr>
</thead>
<tbody><tr>
<td>malloc/free 是函数</td>
<td>new/delete 是操作符</td>
</tr>
<tr>
<td>malloc申请的空间不会初始化</td>
<td>new可以初始化</td>
</tr>
<tr>
<td>malloc申请空间时，需要手动计算空间大小并传递</td>
<td>new只需在其后跟上空间的类型即可</td>
</tr>
<tr>
<td>malloc返回值为void *，在使用时必须强转</td>
<td>new不需要，因为new后面跟的是空间的类型</td>
</tr>
<tr>
<td>malloc申请空间失败时，返回的是NULL，因此使用时必须判空</td>
<td>new不需要，但是new需要捕获异常</td>
</tr>
<tr>
<td>申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数和析构函数</td>
<td>new在申请看空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理</td>
</tr>
</tbody></table>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>设计一个类，该类只能在堆上创建对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">//1、将类的构造函数私有，拷贝构造函数声明成私有。防止别人调用拷贝在栈上生成对象</span></span><br><span class="line"><span class="comment">//2、提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Object* <span class="title">GetObject</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Object(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Object()</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// C++98</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="comment">//	Object(const Object&amp; o);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	<span class="comment">// 1. 释放new的空间</span></span><br><span class="line">	<span class="comment">// 2. 在默认成员函数后跟上=delete, 删除默认的拷贝构造函数</span></span><br><span class="line">	Object(<span class="keyword">const</span> Object&amp; o) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Object(<span class="keyword">int</span> data)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户</span></span><br><span class="line"><span class="comment">//Object::Object(const Object&amp;)</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Object* p= Object::GetObject(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">o</span><span class="params">(*p)</span></span>;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象(三)</title>
    <url>/2019/11/17/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1(%E4%B8%89)/</url>
    <content><![CDATA[<h1 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h1><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>声明为static的类成员称为类的<strong>静态成员</strong>，用static修饰的成员变量，称之为<strong>静态成员变量</strong>；用static修饰的成员函数，称之为<strong>静态成员函数</strong>。<br><strong>静态的成员变量一定要在类外进行初始化</strong></p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>1、静态成员为所有类对象所共享，不属于某个具体的实例<br>2、静态成员变量必须在类外定义，定义时不添加static关键字<br>3、类静态成员即可用类名::静态成员或者对象.静态成员来访问<br>4、静态成员函数没有隐藏的this指针，不能访问任何非静态成员<br>5、静态成员和类的普通成员一样，也要public、private、protected三种访问级别，也可以具有返回值</p>
<p>另：C++11支持非静态成员变量在声明时进行初始化赋值，但是需要注意这里不是初始化，这里是给声明的成员变量缺省值</p>
<p>附：<br>静态成员变量和一般成员变量的区别：</p>
<table>
<thead>
<tr>
<th>静态类型成员变量</th>
<th>普通类型成员变量</th>
</tr>
</thead>
<tbody><tr>
<td>static关键字</td>
<td>不需要</td>
</tr>
<tr>
<td>类外进行初始化</td>
<td>初始化列表（完全属于该对象的变量）</td>
</tr>
<tr>
<td>为所有对象共享</td>
<td>每个对象中都包含一份</td>
</tr>
<tr>
<td>对象::静态成员变量 / 对象.静态成员变量</td>
<td>只能通过对象访问</td>
</tr>
<tr>
<td>静态成员变量不会影响类对象的大小（sizeof结果）</td>
<td></td>
</tr>
<tr>
<td>存储位置：静态区</td>
<td></td>
</tr>
</tbody></table>
<p>静态成员函数和一般成员函数的区别：<br>|静态类型成员函数|普通类型成员函数  |<br>|–|–|<br>| 不能访问普通类的成员变量 | 可以访问普通类的成员变量 |<br>|只能访问静态成员变量|可以访问静态成员变量|<br>|没有隐藏的this指针|有隐藏的this指针|<br>|不能用const修饰|可以用const修饰|<br>|可以不用通过对象调用|必须通过对象调用|</p>
<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>友元提供了一种突破封装的方式，有时候会提供便利。但是友元会增加耦合度，破坏封装，所以友元不宜多用</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><h6 id="operator-lt-lt-重载"><a href="#operator-lt-lt-重载" class="headerlink" title="operator&lt;&lt; 重载"></a>operator&lt;&lt; 重载</h6><p>当用运算符重载的规则去重载cout的输出运算符时，会发现没办法将operator&lt;&lt; 重载为成员函数。因为<strong>cout的输出流对象和隐含的this指针在抢占第一个参数的位置</strong>。this指针默认是第一个参数也就是左操作数。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以要将operator&lt;&lt; 重载成全局函数。但是这样的话，又会导致类外没办法访问成员，所以这里面引入了友元的概念。</p>
<p><strong>友元函数</strong>可以<strong>直接访问</strong>类的<strong>私有成员</strong>，它是<strong>定义在类外部</strong>的普通函数，不属于任何类，但是需要在类的内部声明，声明时需要加<strong>friend</strong>关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);</span><br><span class="line">public:</span><br><span class="line">	Date(int year, int month, int day)</span><br><span class="line">		:_year(year)</span><br><span class="line">		, _month(month)</span><br><span class="line">		, _day(day)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">	 _cout &lt;&lt; d._year &lt;&lt; &quot;-&quot; &lt;&lt; d._month &lt;&lt; &quot;-&quot; &lt;&lt; d._day &lt;&lt; endl;</span><br><span class="line">	return _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Date d(1990, 1, 1);</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：<br>1、友元函数可以访问类的私有成员，但不是类的成员函数<br>2、友元函数不能用const修饰<br>3、友元函数可以在类定义的任何地方声明，不受类访问限定符限制<br>4、一个函数可以是多个类的友元函数<br>5、友元函数的调用与普通函数的调用和原理相同</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。其中：<br>1、友元关系是单向的，不具有交换性<br>2、友元关系不能传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date;</span><br><span class="line">class Time</span><br><span class="line">&#123;</span><br><span class="line">	friend class Date;</span><br><span class="line">public:</span><br><span class="line">	Time(int hour = 0, int minute = 0, int second = 0)</span><br><span class="line">		: _hour(hour)</span><br><span class="line">		, _minute(minute)</span><br><span class="line">		, _second(second)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int _hour;</span><br><span class="line">	int _minute;</span><br><span class="line">	int _second;</span><br><span class="line"></span><br><span class="line">	friend void Print();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year, int month, int day)</span><br><span class="line">		: _year(year)</span><br><span class="line">		, _month(_day)</span><br><span class="line">		, _day(day)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	void PrintDate()const</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">	Time _t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><p>如果一个类定义在另一个类的内部，这个内部的类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。<br>注意：内部类就是外部类的友元。内部类可以通过外部类的对象参数来访问外部类中的所有成员，但是外部类不是内部类的友元。</p>
<h6 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h6><p>1、内部类可以定义在外部类的public、protected、private都是可以的<br>2、注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名<br>3、sizeof(外部类) = 外部类，和内部类没有任何关系</p>
<br/>
以上]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象(二)</title>
    <url>/2019/11/17/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1(%E4%BA%8C)/</url>
    <content><![CDATA[<p>类的六个默认成员函数<br>如果一个类中什么成员都没有，简称为空类，可是空类中就什么都没有吗？并不是的，任何一个类在我们不写的情况下，都会自动生成下列六个成员函数：<br><img src="https://img-blog.csdnimg.cn/20190915175454888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数是一个特殊的成员函数，名字与类型相同，创建类型对象时有编译器自动调用，保证每个数据成员都有一个合适的初值，并且在对象的生命周期内只调用一次</p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>构造函数是特殊的成员函数，构造函数虽然名称为构造，但是需要注意的是构造函数的主要任务并不是开辟空间创建对象，而是初始化对象</p>
<p>具体特征：<br>1、函数名与类名相同<br>2、无返回值<br>3、对象实例化时编译器自动调用对应的构造函数<br>4、构造函数可以重载<br>5、如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义后编译器将不再生成<br>6、无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数，我们没写编译器默认生成的构造函数，都可以认为是默认成员函数<br>7、C++把类型分成内置类型（基本类型）和自定义类型。内置类型就是语法已经定义好的类型：如int、char…，自定义类型就是我们使用class/struct/union自己定义的类型。编译器生成默认的构造函数会对自定义类型成员_t调用它的默认成员函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">// 	Date()    // 类中如果没有显式(用户是否直接定义)任何构造函数， 编译器将会生成一个默认的构造函数---无参构造函数</span><br><span class="line">// 	&#123;</span><br><span class="line">// 		_year = 1900;</span><br><span class="line">// 		_month = 1;</span><br><span class="line">// 		_day = 1;</span><br><span class="line">// 	&#125;</span><br><span class="line">	Date(int year, int month, int day)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void PrintDate()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Date d1;  //调用无参构造函数</span><br><span class="line">	Date d2(2019, 9, 15);  //调用带参构造函数</span><br><span class="line">    //Date d3();  //注意：如果通过无参构造函数初始化对象时，对象后面不用跟括号，否则就成了函数声明。而该函数声明了d3函数，该函数无参，返回一个日期类型的对象</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的其他用法"><a href="#构造函数的其他用法" class="headerlink" title="构造函数的其他用法"></a>构造函数的其他用法</h4><h6 id="构造函数体赋值"><a href="#构造函数体赋值" class="headerlink" title="构造函数体赋值"></a>构造函数体赋值</h6><p>在创建对象时，编译器通过调用构造函数，给对象中的每个成员变量一个合适的初始值</p>
<p>构造函数体中的语句只能将其称作为赋初值，而不能称为初始化。因为初始化只能初始一次，而构造函数体内可以多次赋值</p>
<h6 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h6><p>以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个“成员变量”后面跟一个放在括号中的初始值或表达式<br>【注意】<br>1、每个成员变量在初始化列表中<strong>只能出现一次</strong>(初始化只能初始化一次)<br>2、类中包含以下成员变量，必须放在初始化列表位置进行初始化：<br>  （1）、引用成员变量<br>   （2）、const成员变量<br>   （3）、类类型成员（该类没有默认构造函数）<br>3、<strong>尽量使用初始化列表初始化</strong>。对于自定义类型成员变量，一定会先使用初始化列表初始化<br>4、成员变量<strong>在类中声明次序</strong>就是其<strong>在初始化列表中的初始化顺序</strong>，与其在初始化列表中的先后次序无关</p>
<h6 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h6><p>构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用<br>用explicit修饰构造函数，将会禁止单参构造函数的隐式转换</p>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成一些资源清理工作</p>
<h6 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h6><p>1、析构函数名是在类名前加上字符~<br>2、无参数无返回值<br>3、一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数<br>4、对象生命周期结束时，C++编译系统自动调用析构函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">class SeqList</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	SeqList(size_t capacity = 10)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;SeqList(size_t)&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		_array = (DataType*)malloc(sizeof(DataType)*capacity);</span><br><span class="line">		if (nullptr == _array)</span><br><span class="line">		&#123;</span><br><span class="line">			assert(0);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_capacity = 0;</span><br><span class="line">		_size = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~SeqList()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;~SeqList()&quot; &lt;&lt; endl;</span><br><span class="line">		if (_array)</span><br><span class="line">		&#123;</span><br><span class="line">			free(_array);</span><br><span class="line">			_array = nullptr;</span><br><span class="line">			_capacity = 0;</span><br><span class="line">			_size = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	DataType* _array;</span><br><span class="line">	size_t _size;</span><br><span class="line">	size_t _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	SeqList s;</span><br><span class="line">	 _CrtDumpMemoryLeaks();  //检测是否存在内存泄漏</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、编译器生成的默认析构函数，会对自定义类型成员调用它们的析构函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	String(const char* str = &quot;&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		if (nullptr == str)</span><br><span class="line">			str = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">		_str = (char*)malloc(strlen(str) + 1);</span><br><span class="line">		strcpy(_str, str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~String()</span><br><span class="line">	&#123;</span><br><span class="line">		if (_str)</span><br><span class="line">		&#123;</span><br><span class="line">			free(_str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char* _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	String _name;</span><br><span class="line">	String _gender;</span><br><span class="line">	int _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），在用已存在的类类型对象创建新对象时由编译器自动调用</p>
<h6 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h6><p>1、拷贝构造函数是构造函数的一个重载形式<br>2、拷贝构造函数的参数只有一个且必须使用引用传参，使用传值的方式在传参的位置会引发无穷递归调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year = 1900, int month = 1, int day = 1)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Date(const Date&amp; d)  //此处，参数必须为引用类型。原因：传值会形成临时拷贝，而该函数为对象的拷贝函数，所以会导致不断地传值，不断形成临时拷贝...致使程序陷入死循环</span><br><span class="line">	&#123;</span><br><span class="line">		_year = d._year;</span><br><span class="line">		_month = d._month;</span><br><span class="line">		_day = d._day;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void SetDate(int year, int month, int day)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void PrintDate()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Date d1(2019, 9, 14);</span><br><span class="line">	Date d2(d1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、若未显式定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们称之为浅拷贝，或者值拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	String(const char* str = &quot;&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		if (nullptr == str)</span><br><span class="line">			str = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">		_str = (char*)malloc(strlen(str) + 1);</span><br><span class="line">		strcpy(_str, str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~String()</span><br><span class="line">	&#123;</span><br><span class="line">		if (_str)</span><br><span class="line">		&#123;</span><br><span class="line">			free(_str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	char* _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	String s1(&quot;hello&quot;);</span><br><span class="line">	String s2(s1);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该程序会运行出错。</span><br><span class="line">//原因：由于是编译器默认生成的拷贝函数，该函数的拷贝形式为浅拷贝，即将一个对象中的内容原封不动的拷贝到另外一个对象中。</span><br><span class="line">//而若当前对象中的内容为指向一片内存空间的指针的话，那么拷贝后的对象内容也指向这一片内存空间</span><br><span class="line">//当调用析构函数时，将第一个对象所指向的空间释放之后，致使另一个对象为野指针。如下图：</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190915235418223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><p>目的：为了增强代码的可读性<br>函数名字：关键字operator后面接需要重载的运算符符号<br>函数原型：返回值类型  operator操作符 (参数列表)</p>
<p>注意：<br>1、不能通过连接其他符号来创建新的操作符：比如operator@，关于哪些运算符能被重载，有下图<br><img src="https://img-blog.csdnimg.cn/20190916000202615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、重载操作符必须有一个类类型或者枚举类型的操作数<br>3、用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能重载的时候定义为 - 的作用<br>4、作为类成员的重载函数时，其形参看起来比操作数数目少1，成员函数的操作符有一个默认的形参this，限定为第一个形参<br>5、” .* “ 、” :: “ 、” sizeof “ 、” ?: “  、” . “，注意以上的5个运算符不能重载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year = 1900, int month = 1, int day = 1)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator==(const Date&amp; d)</span><br><span class="line">	&#123;</span><br><span class="line">		return _year == d._year &amp;&amp;  _month == d._month &amp;&amp;   _day == d._day;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="赋值运算符重载-1"><a href="#赋值运算符重载-1" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year = 1900, int month = 1, int day = 1)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Date(const Date&amp; d)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = d._year;</span><br><span class="line">		_month = d._month;</span><br><span class="line">		_day = d._day;</span><br><span class="line">	&#125;</span><br><span class="line">    bool operator!=(const Date&amp; d)  //为了赋值运算符重载的顺利进行，引入不等于的运算符重载</span><br><span class="line">	&#123;</span><br><span class="line">		return !(*this == d);</span><br><span class="line">	&#125;</span><br><span class="line">	Date&amp; operator=(const Date&amp; d)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;d)  //禁止自己给自己赋值</span><br><span class="line">		&#123;</span><br><span class="line">			_year = d._year;</span><br><span class="line">			_month = d._month;</span><br><span class="line">			_day = d._day;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="、-运算符重载"><a href="#、-运算符重载" class="headerlink" title="+ +、- -运算符重载"></a>+ +、- -运算符重载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year = 1900, int month = 1, int day = 1)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Date(const Date&amp; d)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = d._year;</span><br><span class="line">		_month = d._month;</span><br><span class="line">		_day = d._day;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 前置++</span><br><span class="line">	Date&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		_day += 1;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 后置++</span><br><span class="line">	Date operator++(int)</span><br><span class="line">	&#123;</span><br><span class="line">		Date temp(*this);</span><br><span class="line">		_day += 1;</span><br><span class="line"></span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Date&amp; operator--()</span><br><span class="line">	&#123;</span><br><span class="line">		_day -= 1;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Date operator--(int)</span><br><span class="line">	&#123;</span><br><span class="line">		Date temp(*this);</span><br><span class="line">		_day -= 1;</span><br><span class="line"></span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h1><h6 id="const修饰类的成员函数"><a href="#const修饰类的成员函数" class="headerlink" title="const修饰类的成员函数"></a>const修饰类的成员函数</h6><p>被const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明该成员函数中不能对类的任何成员进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year = 1900, int month = 1, int day = 1)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Date* operator&amp;()</span><br><span class="line">	&#123;</span><br><span class="line">		_day++;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Date d1;</span><br><span class="line">	cout &lt;&lt; &amp;d1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	const Date d2;</span><br><span class="line">	cout &lt;&lt; &amp;d2 &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">//该程序运行后，d1中为1900-1-2；d2中为1900-1-1</span><br><span class="line">//可以看出来，由const修饰的类成员函数中的成员变量不会进行任何修改</span><br></pre></td></tr></table></figure>
<p>当然，在const修饰的类成员函数中，若要对成员变量进行修改，只需在私有成员变量定义时，前面加上mutable即可</p>
<p>思考：<br>const对象可以调用非const成员函数吗？<br>——不可以，const类型类型对象中的成员变量不允许被修改，而非const类型的成员函数中允许修改成员变量，两者冲突，若允许的话，会不安全<br>非const对象可以调用const成员函数吗？<br>——可以，非const类型的对象允许修改成员变量，但是若要调用const成员函数是被允许的，不会违背安全性的原则<br>const成员函数内可以调用其他的非const成员函数吗？<br>——不可以，同理…<br>非const成员函数内可以调用其他的const成员函数吗？<br>——可以，同理…</p>
<p><a href="https://blog.csdn.net/woliuyunyicai/article/details/47414915">C和C++中const的区别</a></p>
<h1 id="取地址及const取地址操作符重载"><a href="#取地址及const取地址操作符重载" class="headerlink" title="取地址及const取地址操作符重载"></a>取地址及const取地址操作符重载</h1><p>1、这两个默认成员函数一般不用重新定义，编译器默认会生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Date</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Date(int year = 1900, int month = 1, int day = 1)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		cout &lt;&lt; &quot;Date(int,int,int):&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Date()</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int _year;</span><br><span class="line">	int _month;</span><br><span class="line">	int _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到指定的内容</p>
<p><a href="https://blog.csdn.net/qq_43746320/article/details/100869643">涵盖本篇博客所有知识的Date类</a></p>
<p>以上</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类与对象(一)</title>
    <url>/2019/11/17/C++%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1(%E4%B8%80)/</url>
    <content><![CDATA[<p>C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题<br>C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>C语言中，结构体只能定义变量，C++中，结构体内不仅可以定义变量，也可以定义函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">	void SetPersonInfo(const char* name, const char* gender, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		strcpy(_name, name);</span><br><span class="line">		strcpy(_gender, gender);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void PrintPersonInfo()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; _name &lt;&lt; &quot; &quot; &lt;&lt; _gender &lt;&lt; &quot; &quot; &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	char _name[20];</span><br><span class="line">	char _gender[3];</span><br><span class="line">	int _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Person s;</span><br><span class="line">	s.SetPersonInfo(&quot;Adam-Xi&quot;, &quot;男&quot;, 20);</span><br><span class="line">	s.PrintPersonInfo();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形如上述结构体的定义，在C++中更喜欢用class来代替</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class className</span><br><span class="line">&#123;</span><br><span class="line">    //类体：由成员函数和成员变量组成</span><br><span class="line">&#125;;  //一定要注意后面的分号</span><br></pre></td></tr></table></figure>
<p>class为定义类的关键字，className为类的名字，{}中为类的主体，注意类定义结束时后面的分号。<br>类中的元素称为类的成员：类中的数据称为类的属性或者成员变量；类中的函数称为类的方法或者成员函数。</p>
<p>类的两种定义方式：<br>1、声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理<br>2、声明放在.h文件中，类的定义放在.cpp文件中<br>一般情况下，更期望采取第二种<br><img src="https://img-blog.csdnimg.cn/20190915155823823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="类的访问限定符"><a href="#类的访问限定符" class="headerlink" title="类的访问限定符"></a>类的访问限定符</h3><p>C++实现封装的方式：用类将对象的属性和方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用<br>三种访问限定符：<strong>public(公有)</strong>、<strong>protected(保护)</strong>、<strong>private(私有)</strong><br>【<strong>访问限定符说明</strong>】<br>1、public修饰的成员在类外可以直接被访问<br>2、protected和private修饰的成员不能直接被访问（此处protected和private是类似的）<br>3、访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止<br>4、class的默认访问权限是private，struct为public（因为struct要兼容C）<br><strong>注意：</strong> 访问限定符只有在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>面向对象的三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong><br>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互<br>封装本质上是一种管理，我们通常使用protected/private把成员封装起来，开放一些共有的成员函数对成员合理的访问</p>
<p>封装的好处：<br>1、可以彻底隐藏方法的内部实现，仅仅提供一个调用的方法给其他人，让其他使用这个类的人不需要关心是如何实现的，只要知道该如何调用就行<br>2、隐藏方法的内部实现的好处，可以让保留调用方法不变的同时，随意修改类的结构，而不影响其他人运行结果<br>3、封装还会分开类的属性，将类的属性分成私有属性和公共属性。私有属性仅供类自身调用，和公共属性也仅提供一个供外部调用的方法<br>4、按照软件的术语，良好的封装是能够减少耦合</p>
<h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域</p>
<h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>用类类型创建对象的过程，称为类的实例化<br>1、类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它<br>2、一个类可以实例化出多个对象，实例化出的对象，占用实际的物理空间，存储类成员变量<br><img src="https://img-blog.csdnimg.cn/20190915163134296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="类对象模型"><a href="#类对象模型" class="headerlink" title="类对象模型"></a>类对象模型</h3><p>先看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//类中既有成员函数，又有成员变量</span><br><span class="line">class A1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void f1()&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">	int _a;</span><br><span class="line">&#125;;</span><br><span class="line">//类中只有成员函数</span><br><span class="line">class A2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void f2()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//空类</span><br><span class="line">class A3</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; sizeof(A1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; sizeof(A2) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; sizeof(A3) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序后得出的结果为：  4，1，1</p>
<p>结合资料可以得出：一个类的大小，实际就是该类中“成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类</p>
<p>对非空类而言，类对象的大小，与成员函数无关，等同于计算结构体的大小</p>
<h6 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h6><p>1、第一个成员在与结构体偏移量为0的地址处<br>2、其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VS中默认对齐数为8，gcc中对齐数为4<br>3、结构体总大小为：最大对齐数（所有变量类型最大值与默认对齐数取最小）的整数倍<br>4、如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>C++编译器给每个“成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象（函数运行时调用该函数对象），在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户来说是透明的，即用户不需要传递参数，编译器自动完成</p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>1、this指针的类型：类类型 *const<br>2、只能在“成员函数”的内部使用<br>3、this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针<br>4、this指针是成员函数第一个隐含的指针形参，一般情况下由编译器通过ecx寄存器自动传递，不需要用户传递<br><img src="https://img-blog.csdnimg.cn/20190915173040496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>以上</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux权限</title>
    <url>/2019/11/14/Linux%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="Linux权限概念"><a href="#Linux权限概念" class="headerlink" title="Linux权限概念"></a>Linux权限概念</h1><p>Linux下有两种用户：超级用户（root）、普通用户</p>
<blockquote>
<p>超级用户：可以在Linux系统下做任何事情，不受限制<br>普通用户：在Linux下做有限的事情<br>超级用户的命令提示符是”#”，普通用户的命令提示符是”$”</p>
</blockquote>
<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><h3 id="1、文件访问者的分类"><a href="#1、文件访问者的分类" class="headerlink" title="1、文件访问者的分类"></a>1、文件访问者的分类</h3><blockquote>
<p>文件和文件目录的所有者：u–User<br>文件和文件目录的所有者所在的组的用户：g–Group<br>其他用户：o–Others</p>
</blockquote>
<p>简单的举个栗子区分一下三者：<br>就好像我有一台电脑，我可以使用我的电脑，我的室友也可以使用我的电脑，但是其他不相干的人怎么能使用我的电脑？（例子不算贴切，但足以说明问题）<br>上述例子中，电脑就是该文件，我就是文件的所有者，我的室友就是文件的所有组用户，其他不相干的人就是其他用户</p>
<h3 id="2、文件类型和访问权限"><a href="#2、文件类型和访问权限" class="headerlink" title="2、文件类型和访问权限"></a>2、文件类型和访问权限</h3><p>下图是我的一个目录中的文件信息（使用ls -l指令列出文件的详细信息）：<br><img src="https://img-blog.csdnimg.cn/2019111414302950.png" alt="file type"><br>其中：<br>1、第一位表示文件类型，当前目录中显示的文件类型有两种，为“-”和“d”</p>
<blockquote>
<p>各文件类型表示的含义<br>d：文件夹<br>-：普通文件<br>l：软链接，类似windows的快捷方式<br>b：块设备文件，如硬盘、光驱等<br>p：管道文件<br>c：字符设备文件，如屏幕等串口设备<br>s：套接口文件</p>
</blockquote>
<p>2、紧跟其后的9位字符表示权限，如第一个文件形如“rw-rw-r–”</p>
<blockquote>
<p>基本权限：<br>读(r)：read，对于文件而言，具有读取文件内容的权限；对于目录而言，具有浏览该目录信息的权限<br>写(w)：write，对于文件而言，具有修改文件内容的权限；对于目录而言，具有删除移动目录内的文件的权限<br>执行(x)：execute，对文件而言，具有执行文件的权限；对于目录而言，具有进入目录的权限<br>“<strong>-</strong>”：表示不具有该项权限<br><br/><br>解析Linux下文件权限：<br>权限前三位表示文件所有者的权限<br>权限中间三位表示文件所属用户组的权限<br>权限后三位表示其他用户的权限</p>
</blockquote>
<p>3、其后，跟着的分别为：连接数，所属用户，所属用户组，文件大小，文件最新修改日期，文件名<br><img src="https://img-blog.csdnimg.cn/20191114151335232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="file"></p>
<h3 id="文件权限值的表示方法"><a href="#文件权限值的表示方法" class="headerlink" title="文件权限值的表示方法"></a>文件权限值的表示方法</h3><table>
<thead>
<tr>
<th>Linux表示</th>
<th>说明</th>
<th>二进制</th>
<th>八进制</th>
</tr>
</thead>
<tbody><tr>
<td>r–</td>
<td>只读</td>
<td>100</td>
<td>4</td>
</tr>
<tr>
<td>-w-</td>
<td>只写</td>
<td>010</td>
<td>2</td>
</tr>
<tr>
<td>–x</td>
<td>仅可执行</td>
<td>001</td>
<td>1</td>
</tr>
<tr>
<td>rw-</td>
<td>可读可写</td>
<td>110</td>
<td>6</td>
</tr>
<tr>
<td>r-x</td>
<td>可读可执行</td>
<td>101</td>
<td>5</td>
</tr>
<tr>
<td>-wx</td>
<td>可写可执行</td>
<td>011</td>
<td>3</td>
</tr>
<tr>
<td>rwx</td>
<td>可读可写可执行</td>
<td>111</td>
<td>7</td>
</tr>
<tr>
<td>---</td>
<td>无权限</td>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>### 文件访问权限的设置方法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### chmod</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>功能：设置文件的访问权限</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>格式：chmod [参数] 权限 文件名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>常用选项：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>R：递归修改目录文件的权限<br>说明：只有文件的拥有者和root才可以改变文件的权限</p>
</blockquote>
<p>1、用户标识符+/- = 权限字符</p>
<blockquote>
<p>+：向权限范围增加权限代号所表示的权限<br>-：向权限范围取消代号所表示的权限<br>=：向权限范围赋予权限代号所表示的权限<br><br/><br>用户符号：<br>u：拥有者<br>g：拥有者同组用<br>o：其他用户<br>a：所有用户<br>例：<br>//对test.cpp文件给其他用户增加写权限<br>chmod o+w ./test.cpp</p>
</blockquote>
<p>2、三位8进制数字</p>
<blockquote>
<p>//对当前目录下的test.cpp文件所有者和所属组用户增加权限至可读可写不可执行权限<br>chmod 666 ./test.cpp<br>//对当前目录下的test.cpp文件的所有者和所属组和其他用户都增加权限至可读可写不可执行<br>chmod 777 ./test.cpp</p>
</blockquote>
<h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>功能：修改文件的拥有者<br>格式：chown [参数] 用户名 文件名<br>举例:</p>
<blockquote>
<p>//修改文件test.cpp的所有者为adam-xi（用户名）<br>chown adam-xi test.cpp<br>//修改目录work下的所有文件的所有者为adam-xi<br>chown -R adam-xi work</p>
</blockquote>
<h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>功能：修改文件或目录的所属组<br>格式：chgrp [参数] 用户组名 文件名<br>举例：</p>
<blockquote>
<p>//修改当前目录下test.cpp的所属组用户为adam-xi<br>chgrp adam-xi ./test.cpp</p>
</blockquote>
<h4 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h4><p>功能：查看或修改文件掩码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建文件默认权限为0666<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建目录默认权限为0777<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但实际上，我们所创建的文件或目录，看到的权限往往不是上面的值，因为创建文件或目录时还要受到umask的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设默认权限是mask，则实际创建出来的文件权限是：mask &amp; ~umask<br>格式：umask 权限值<br>说明：将现有的存取权限减去权限掩码后，即可产生创建文件是预设权限。root的默认掩码值为0022，普通用户默认为0002</p>
<h1 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h1><blockquote>
<p>可执行权限：如果目录没有可执行权限，则无法cd到目录中<br>可读权限：如果目录没有可读权限，则无法用ls等命令查看目录中的文件内容<br>可写权限：如果目录没有可写权限，则无法在目录中创建文件，也无法在目录中删除文件</p>
</blockquote>
<h3 id="粘滞位"><a href="#粘滞位" class="headerlink" title="粘滞位"></a>粘滞位</h3><p>命令：<strong>chmod +t</strong><br>当一个目录被设置为“粘滞位”，则该目录下的文件只能由</p>
<blockquote>
<p>一、超级管理员删除<br>二、该目录的所有者删除<br>三、该文件的所有者删除<br><br/><br>以上。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C++初探</title>
    <url>/2019/11/12/C++%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h3 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h3><p>C++98/03中，关键字共有<strong>63</strong>个<br><img src="https://img-blog.csdnimg.cn/20190913211553864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>C++11中，关键字共有<strong>73</strong>个：在前面的基础上，新加了alignas、alignof、char16_t、char32_t、constexpr、decltype、noexcept、nullptr、static_assert、thread_local，并对少数几个关键字进行了一定的修改。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在C/C++中，变量、函数和类都是大量存在的，这些变量、函数、类的名称都将作用于全局作用域中，可能会导致很多的冲突。所以，C++中引入namespace关键字，目的是<strong>对标识符的名称进行本地化，以避免命名冲突或名字污染</strong></p>
<h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>1、普通的命名空间 ： namespace关键字， 后面跟命名空间的名字， 然后一对花括号{}即可 ，{}中即为命名空间的成员。<strong>命名空间中的内容，可以是变量，也可以是函数</strong><br>2、命名空间可以嵌套<br>3、同一工程中，允许存在多个相同名称的命名空间，编译器最后会将它们合成到同一个命名空间中<br>4、<strong>一个命名空间就是定义了一个作用域</strong>，命名空间中定义的所有内容的作用范围都局限于该命名空间中</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><blockquote>
<p>三种使用方式：<br>1、加命名空间名称及作用域限定符“ :: ”<br>2、使用using将命名空间中的成员导入<br>3、使用using namespace + 命名空间名称将该命名空间中的成员全部引入</p>
</blockquote>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace N</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	int Add(int left, int right)</span><br><span class="line">	&#123;</span><br><span class="line">		return left + right;</span><br><span class="line">	&#125;</span><br><span class="line">	namespace X</span><br><span class="line">	&#123;</span><br><span class="line">		int c = 10;</span><br><span class="line">		int d = 20;</span><br><span class="line">		int Mul(int left, int right)</span><br><span class="line">		&#123;</span><br><span class="line">			return left * right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using N :: b; //方式2</span><br><span class="line"></span><br><span class="line">using namespace N; //方式3</span><br><span class="line"></span><br><span class="line">using N :: X :: c;</span><br><span class="line">using N :: X :: d;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; N :: a &lt;&lt; endl; //方式1</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; N :: a &lt;&lt; endl; //方式2</span><br><span class="line">	cout &lt;&lt; b &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; //方式3</span><br><span class="line">	cout &lt;&lt; Add(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; N :: X :: Mul(c, d) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-输入-amp-amp-输出"><a href="#C-输入-amp-amp-输出" class="headerlink" title="C++输入 &amp;&amp; 输出"></a>C++输入 &amp;&amp; 输出</h3><p>输入 cin &gt;&gt; 变量1 &gt;&gt; 变量2 &gt;&gt; … ;<br>输出 cout &lt;&lt; 变量/常量/函数 &lt;&lt; … ( &lt;&lt; endl 表示输出后换行,可加可不加) ;</p>
<p>说明：<br>1、使用 cout（标准输出：控制台）和 cin（标准输入：键盘）时，<strong>必须包含<iostream>头文件以及std标准命名空间</strong>，如上述例子<br>2、使用C++输入输出更加方便，不需要增加数据格式控制，如：整形–%d，字符型–%c 等</p>
<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。<br>缺省参数分为全缺省参数和半缺省参数<br>注意：<br>1、半缺省参数必须<strong>从右往左</strong>依次来给出，不能间隔着给<br>2、缺省参数<strong>不能在函数声明和定义中同时出现</strong>。如果声明和定义位置同时出现，恰巧两个位置提供的值不同，那么编译器会因为无法确定用哪个缺省值而报错<br>3、缺省值必须是<strong>常量</strong>或<strong>全局变量</strong><br>4、C语言不支持（编译器不支持）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Func1(int a = 1, int b = 2, int c = 3) //全缺省参数</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">void Func2(int a, int b = 2, int c = 3) //半缺省参数</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Fun1();</span><br><span class="line">	Func1(10);</span><br><span class="line">	Func2(10);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><blockquote>
<p>函数重载是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表（参数个数或类型或顺序）必须不同，常用来处理实现功能类似数据类型不同的问题。</p>
</blockquote>
<p>注意：<strong>几个同名函数要形成函数重载，只与函数的参数列表有关</strong>，函数的参数个数、类型、顺序只要其中之一不同，就能形成函数重载。<strong>与返回值类型无关</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Add(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">	return left + right;</span><br><span class="line">&#125;</span><br><span class="line">double Add(double left, double right)</span><br><span class="line">&#123;</span><br><span class="line">	return left + right;</span><br><span class="line">&#125;</span><br><span class="line">long Add(long left, long right)</span><br><span class="line">&#123;</span><br><span class="line">	return left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Add(10, 20);</span><br><span class="line">	Add(10.0, 20.0);</span><br><span class="line">	Add(10L, 20L);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="名字修饰-name-Mangling"><a href="#名字修饰-name-Mangling" class="headerlink" title="名字修饰(name Mangling)"></a>名字修饰(name Mangling)</h6><p>在C/C++中，一个程序要运行起来，需要经历以下几个阶段：<strong>预处理、编译、汇编、链接</strong>。<br>Name Mangling是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过某种算法，重新修饰为一个全局唯一的名称。<br><strong>C语言的名字修饰规则，是在函数名字前面加下划线</strong>，因此当工程中存在相同函数名的函数时，就会产生冲突，所以C语言并不支持函数重载。</p>
<p>由于C++要支持函数重载、命名空间等，使其修饰规则较为复杂，不同编译器在底层的产生方式都有可能产生差异。<br>在VS下，编译器在底层使用的不是函数名字，而是被重新修饰过的一个比较复杂的名字，<strong>被重新修饰后的名字中包含了：函数的名字以及参数类型</strong>。这就是为什么函数重载中几个同名函数要求其参数列表不同的原因，<strong>只要参数列表不同，编译器在编译时通过对函数名字进行重新修饰，将参数类型包含在最终的名字中，就可以保证名字在底层的唯一性</strong>。</p>
<h5 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h5><p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思就是告诉编译器，将函数按照C语言规则来编译</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h6><p>引用不是新定义的一个变量，而是给已存在的变量取了一个<strong>别名</strong>，编译器不会为引用变量开辟空间，它和它引用的变量共用同一块内存空间。<br>类型&amp; 引用变量名(对象名) = 引用实体；<br><strong>注意：引用类型必须和引用实体是同种类型的</strong></p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>1、引用在定义时必须<strong>初始化</strong><br>2、<strong>一个变量可以有多个引用</strong><br>3、<strong>引用一旦引用一个实体，再不能引用其他实体</strong>。这就是它为什么要被初始化的原因<br>4、在实际的程序中，引用主要被用做函数的形式参数，通常将类对象传递给一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Func()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	//int&amp; ra;  //该条语句编译时会出错，未初始化</span><br><span class="line">	int&amp; ra = a;</span><br><span class="line">	int&amp; rra = a;</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; &amp;ra &lt;&lt; &amp;rra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h6><p>const引用可以用不同类型的对象初始化(只要能从一种类型转换到另一种类型即可)，也可以是不可寻址的值，如文字常量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	const int a = 10;</span><br><span class="line">	//int&amp; ra = a;    //该语句编译时会出错，a为常量</span><br><span class="line">	const int&amp; ra = a;</span><br><span class="line">	//int&amp; b = 10;    //该语句编译时会出错，b为常量</span><br><span class="line">	const int&amp; b = 10;</span><br><span class="line"></span><br><span class="line">	double d = 12.34;</span><br><span class="line">	//int&amp; rd = d;    //该语句编译时会出错，类型不同</span><br><span class="line">	const int&amp; rd = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>1、做参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 采用引用做函数的参数</span><br><span class="line">void Swap(int&amp; left, int&amp; right)</span><br><span class="line">&#123;</span><br><span class="line"> int temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意： 如果想要通过形参改变外部实参，形参类型：普通类型引用</span><br><span class="line">//       如果不想通过形参改变外部实参，形参类型：const类型引用</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int a = 10;</span><br><span class="line"> int&amp; ra = a;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、做返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引用：可以作为函数的返回值</span><br><span class="line">int g_a = 0;</span><br><span class="line"></span><br><span class="line">int&amp; Add(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line"> int ret = left + right;</span><br><span class="line"> return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sub(int left, int right)</span><br><span class="line">&#123;</span><br><span class="line"> int ret = left - right;</span><br><span class="line"> return ret;</span><br><span class="line">&#125;</span><br><span class="line">// 注意：不要返回函数栈上的空间</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int&amp; r = Add(1, 2);</span><br><span class="line"> //Sub(10, 5);</span><br><span class="line"> Add(3, 4);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果函数返回时，离开函数作用域后，其栈上的空间已经返还给系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制（即比函数生命周期长）</p>
<h6 id="传值、传引用效率比较"><a href="#传值、传引用效率比较" class="headerlink" title="传值、传引用效率比较"></a>传值、传引用效率比较</h6><p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回值变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // 传参效率比较：传值最慢(值得拷贝)，传地址和传引用效率几乎一样</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> struct A</span><br><span class="line"> &#123;</span><br><span class="line">	 int a[10000];</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void TestFunc1(A* a)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> void TestFunc2(A&amp; a)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> void TestRefAndValue()</span><br><span class="line"> &#123;</span><br><span class="line">	 A a;</span><br><span class="line">	// 以值作为函数参数</span><br><span class="line">	size_t begin1 = clock();</span><br><span class="line">	 for (size_t i = 0; i &lt; 10000; ++i)</span><br><span class="line">		 TestFunc1(&amp;a);</span><br><span class="line">	 size_t end1 = clock();</span><br><span class="line"></span><br><span class="line">	 // 以引用作为函数参数</span><br><span class="line">	 size_t begin2 = clock();</span><br><span class="line">	 for (size_t i = 0; i &lt; 10000; ++i)</span><br><span class="line">		 TestFunc2(a);</span><br><span class="line">	 size_t end2 = clock();</span><br><span class="line">	 // 分别计算两个函数运行结束后的时间</span><br><span class="line">	 cout &lt;&lt; &quot;TestFunc1(int*)-time:&quot; &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">	 cout &lt;&lt; &quot;TestFunc2(int&amp;)-time:&quot; &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 运行多次，检测值和引用在传参方面的效率区别</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">	 for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">	 &#123;</span><br><span class="line">		 TestRefAndValue();</span><br><span class="line">	 &#125;</span><br><span class="line">	 return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>同样，值和引用作为返回值类型的性能同样差距很大。</p>
<h6 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h6><p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间<br>在底层实现上实际是有空间的，因为<strong>引用是按照指针的方式来实现的</strong><br>具体区别如下：<br>1、引用在定义时必须初始化，指针没有要求<br>2、引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体<br>3、没有NULL引用，但有NULL指针<br>4、在sizeof中含义不同：<strong>引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）</strong><br>5、引用自加即引用的实体加1，指针自加即指针向后偏移一个类型的大小<br>6、有多级指针，但是没有多级引用<br>7、访问实体方式不同，<strong>指针需要显示解引用</strong>，<strong>引用编译器自己处理</strong><br>8、引用比指针使用起来相对安全</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><blockquote>
<p>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升了程序的运行效率。</p>
</blockquote>
<p>特性：<br>1、inline是一种<strong>以空间换时间</strong>的做法，省去函数调用的额外开销。所以<strong>代码很长或者有循环/递归函数不宜使用作为内联函数</strong><br>2、inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等，编译器优化时会忽略掉内联函数<br>3、<strong>inline不建议声明和定义分离</strong>，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到</p>
<h3 id="auto关键字（C-11）"><a href="#auto关键字（C-11）" class="headerlink" title="auto关键字（C++11）"></a>auto关键字（C++11）</h3><p>在C++11中，auto被赋予了全新的含义：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须有编译器在编译时期推导而得</p>
<pre><code>// 编译器在编译阶段，根据提供的初始化表达式实际类型，来确定变量的类型

int main()
{
    auto a = 10;
    auto b = 12.34;
    //auto c;  //无法编译通过，使用auto定义变量时必须对其进行初始化
    cout &lt;&lt; typeid(a).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;
    return 0;
}</code></pre><p>注意：使用auto定义变量时必须对其进行初始化，在编译阶段需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型</p>
<h6 id="auto使用细则"><a href="#auto使用细则" class="headerlink" title="auto使用细则"></a>auto使用细则</h6><p>1、auto与指针和引用结合起来使用<br>用auto声明指针类型时，<strong>用auto和auto*没有任何区别</strong>，但<strong>用auto声明引用类型时必须加&amp;</strong><br>2、在同一行定义多个变量<br><strong>当在同一行声明多个变量时，这些变量必须是相同的类型</strong>，否则编译器会报错 ，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其它变量<br>3、<strong>auto不能作为函数的参数</strong>，因为编译器无法对形参的类型进行推导<br>4、<strong>auto不能直接用来声明数组</strong><br>5、为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法<br>6、auto在实际中最常见的优势用法就是C++11中提供的<strong>新式for循环</strong>，还有<strong>lambda表达式</strong>等进行配合使用<br>7、auto不能定义类的非静态成员变量<br>8、实例化模板时不能使用auto作为模板参数</p>
<h3 id="基于范围的for循环-C-11"><a href="#基于范围的for循环-C-11" class="headerlink" title="基于范围的for循环(C++11)"></a>基于范围的for循环(C++11)</h3><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>在C++98中，若要编译一个数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] *= 2;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int* p = arr; p &lt; arr + sizeof(arr)/sizeof(arr[0]); p++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个有范围的集合而言，由程序员说明循环的范围是多余的，有时候还会容易出错。因此C++11中引入了基于范围的for循环。for循环后面的括号中有冒号“:”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;;</span><br><span class="line">	for(auto&amp; e : arr)  //让变量e去引用数组中的每一个元素</span><br><span class="line">	&#123;</span><br><span class="line">		e *= 2;</span><br><span class="line">	&#125;</span><br><span class="line">	for(auto e : arr)  //变量e就是数组中每个元素的拷贝</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通for循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环</p>
<h6 id="范围for的使用条件"><a href="#范围for的使用条件" class="headerlink" title="范围for的使用条件"></a>范围for的使用条件</h6><p>1、for循环迭代的范围必须是确定的<br>对于数组而言，就是数组中第一个元素和最后一个元素的范围；<br>对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围<br>2、迭代的对象要实现++和==的操作</p>
<h3 id="指针空值"><a href="#指针空值" class="headerlink" title="指针空值"></a>指针空值</h3><h6 id="C-98中的空值"><a href="#C-98中的空值" class="headerlink" title="C++98中的空值"></a>C++98中的空值</h6><p>在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针，如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Test()</span><br><span class="line">&#123;</span><br><span class="line">    int* p1 = NULL;</span><br><span class="line">    int* p2 = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NULL实际上是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef NULL</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">#define NULL   0</span><br><span class="line">#else </span><br><span class="line">#define NULL   ((void *)0)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void *)的常量。<br>但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强制类型转换(void *)0</p>
<h6 id="nullptr-与-nullptr-t"><a href="#nullptr-与-nullptr-t" class="headerlink" title="nullptr 与 nullptr_t"></a>nullptr 与 nullptr_t</h6><p>为考虑兼容性，C++11中并没有消除常量0的二义性，C++11中给出了全新的nullptr表示空值指针。C++11为什么不在NULL的基础上进行扩展，这是因为NULL以前就是一个宏，而且不同编译器厂商对于NULL的实现可能不大相同，而且直接扩展NULL，可能会影响到以前旧的程序。因此，为了避免混淆，C++11中提供了nullptr，即nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类型<br>注意：<br>1、在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的<br>2、在C++11中，sizeof(nullptr) 与 sizeof((void *)0) 所占字节数相同<br>3、为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C总结</title>
    <url>/2019/11/12/C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190921234557107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本指令</title>
    <url>/2019/11/11/Linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>本篇文章中，对Linux中的基本指令的常用用法进行讲解，对于刚接触linux系统的童鞋来说比较友好，不足之处，还望批评指出！</p>
<p>正文：</p>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>语法：ls [选项] [目录或文件]<br>功能：对于目录，将列出该目录下所有子目录和文件；对于文件，将列出文件的所有信息<br>常用选项：</p>
<blockquote>
<p>-a：列出目录下的所有文件，包含隐含文件<br>-l： 列出文件的详细信息<br>-r： 对目录反向排序<br>-t： 以时间排序<br>-R： 递归列出所有子目录下的文件</p>
</blockquote>
<h6 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h6><p>1、各种选项可以进行组合使用<br>2、这里只列举几种最常用的选项，并不是所有的选项</p>
<h6 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h6><blockquote>
<p>ls  //列出当前目录下的文件和目录名称<br>ls -a  //列出当前目录下的所有文件和目录名称<br>ls -l   //列出当前目录下的文件和目录的详细信息，可简写为 ll<br>ls -a -l   //列出当前目录下的所有文件和目录的详细信息，可简写为 ls -la<br>ls -l -t    //以时间排序，距现在最近的创建修改时间的文件或目录排在最前面（顶部），简写为 ls -lt<br>ls -l -r -t  //以时间反向排序，距现在最近的文件或目录排在最底部，简写 ls -lrt ，这条命令非常实用方便</p>
</blockquote>
<p>注意：该用例中的所有简写方式中的选项组合没有先后之分，且文章往后都默认没有，若有次序之分，会实现说明</p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>语法：pwd<br>功能：显示用户当前所在的目录，即路径</p>
<h6 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h6><p>该命令经常单用，显示当前用户所在的目录，且显示的路径是绝对路径</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>语法：cd 目录名/<br>功能：改变工作目录，将当前工作目录改变到指定的目录下<br>常用搭配：</p>
<blockquote>
<p>cd ~ ： 进入用户的家目录<br>cd - ： 返回上一次访问的目录<br>cd / ： 返回根目录<br>cd /home/adam_xi/workstation/ : 绝对路径<br>cd ./ ： 切换到当前目录（没变）<br>cd ../ ： 切换到上层目录（返回到“父节点”）<br>cd ../test/ ：相对路径<br>cd 目录名/</p>
</blockquote>
<h6 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h6><p>1、在Linux系统中，磁盘上的文件和目录被组织成一棵目录树，每个节点都是目录或文件<br>从目录树的根节点到某个节点的路径称为绝对路径<br>从目录树中的当前节点改变到某个节点的路径称为相对路径<br>2、Linux目录结构中，任一目录下都会有 <strong>.</strong> 和 <strong>..</strong> 两个默认<strong>隐藏目录</strong>, .为当前目录， ..为上层目录</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>语法：touch [选项] [路径下的文件名]<br>功能：可更改文档或目录的日期时间（创建时间，存取时间），最主要的功能是<strong>创建新文件</strong><br>选项：</p>
<blockquote>
<p>-a ： 只更改存取时间<br>-d ： 使用指定的日期时间<br>-m ： 只更改变动时间<br>-r ：  把指定文档或目录的时间日期，全部更改为和参考文档或目录的日期时间相同<br>-t ： 使用指定的日期时间，而非现在的时间</p>
</blockquote>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>语法：mkdir [选项] [目录名]<br>功能：在当前目录下创建一个目录<br>选项：</p>
<blockquote>
<p>-p ： 后面可以跟一个路径名称，若路径中某些目录不存在，加上此选项后，将自动生成不存在的目录，即一次性创建多个目录<br>例：mkdir grap/father/child ：递归创建多个目录</p>
</blockquote>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>语法：rm [选项] [文件名/目录名]<br>功能：删除文件后目录<br>选项：</p>
<blockquote>
<p>-f ： 即使文件属性为只读，也直接删除<br>-i ： 删除前逐一询问确认<br>-r ： 删除目录及以下所有文件</p>
</blockquote>
<h6 id="tips-2"><a href="#tips-2" class="headerlink" title="tips"></a>tips</h6><p>1、该操作适用所有使用者<br>2、删除要慎用<br>尤其rm -rf / 一般情况下禁止使用，它会删除linux系统中所有的文件，不要问我为什么知道-_-</p>
<h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>语法：man [选项] [指令名]<br>功能：查看联机手册<br>选项：</p>
<blockquote>
<p>-k ： 根据关键字搜索联机帮助<br>num ： 只在第num章节找<br>-a ： 将所有的章节都显示出来</p>
</blockquote>
<h6 id="tips-3"><a href="#tips-3" class="headerlink" title="tips"></a>tips</h6><p>1、Linux中有很多的命令，参数，我们不可能全都记住，那么，有一个man的指令查询命令就帮助我们进行查询<br>2、man手册分为八个章节<br>（1）、普通的命令<br>（2）、系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)<br>（3）、库函数,如printf,fread<br>（4）、特殊文件,也就是/dev下的各种设备文件<br>（5）、指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义<br>（6）、给游戏留的,由各个游戏自己定义<br>（7）、附件还有一些变量,比如向environ这种全局变量在这里就有说明<br>（8）、系统管理用的命令,这些命令只能由root使用,如ifconfig</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>语法：cp [选项] [源文件或目录] [目标文件或目录]<br>功能：复制文件或目录<br>常用选项：</p>
<blockquote>
<p>-f ： 强制复制，不管文件或目录是否打开<br>-i ： 覆盖文件之前询问用户<br>-r ： 递归处理，将指定目录下的文件与子目录一并处理</p>
</blockquote>
<h6 id="tips-4"><a href="#tips-4" class="headerlink" title="tips"></a>tips</h6><p>用于复制文件或目录，如果同时指定两个以上的文件或目录，且最后一个的目的地是另一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时制定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>语法：mv [选项] [源文件或目录] [目标文件或目录]<br>功能：<br>1、当第二个参数是目录时，移动操作<br>2、当第二个参数是文件时，重命名操作</p>
<p>常用选项：</p>
<blockquote>
<p>-f ： 如果目标文件已存在，不询问而直接覆盖<br>-i ： 如果目标文件已存在，询问是否覆盖</p>
</blockquote>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>语法：cat [选项] [文件]<br>功能：查看目标文件的内容，适合小文件，全部展示<br>常用选项：</p>
<blockquote>
<p>-b ： 对非空输出行编号<br>-n ： 对输出的所有行编号<br>-s ： 不输出多行空格</p>
</blockquote>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>语法：more [选项] [文件]<br>功能：more命令，功能类似cat，适合大文件，分页展示，并且只能向下翻页<br>选项：</p>
<blockquote>
<p>-n ： 对输出的所有行编号<br>q ： 退出more</p>
</blockquote>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>语法：less [选项] [文件]<br>功能：类似more，适合更大的文件，在查看之前不会加载整个文件，且能进行前后翻页</p>
<p>选项：</p>
<blockquote>
<p>-i ： 忽略搜索时的大小写<br>-N ： 显示每行的行号<br>/字符串 ： 向下搜索字符串<br>?字符串 ： 向上搜索字符串<br>n ： 重复前一个搜索，具体与/或?有关<br>N ： 反向重复前一个搜索<br>q ： 退出</p>
</blockquote>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>语法：head -n&lt;行数&gt; 文件名<br>功能：从头开始展示n行文件内容</p>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>语法：rear [选项] 文件名<br>功能：从尾开始展示文件内容，常用于日志文件的读取</p>
<blockquote>
<p>-f ： 循环读取<br>-n&lt;行数&gt; ： 显示行数</p>
</blockquote>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>1、date以指定格式显示时间：</p>
<blockquote>
<p>[adam_xi@bogon ~]$ date<br>Sun Oct 27 19:01:33 CST 2019</p>
</blockquote>
<p>就我而言，感觉date功能查看时间方面挺鸡肋的，所以省去了具体介绍<br>2、date可以设置系统时间，不过当系统联网后，会自动校验回正确时间</p>
<blockquote>
<p>date -s //设置当前时间，不过需要root权限</p>
</blockquote>
<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>语法：cal [参数] [月份][年份]<br>功能：用于查看日历等时间信息，如只有一个参数，则表示年份，如有两个参数，则表示月份和年份<br>常用选项：</p>
<blockquote>
<p>-3 ： 显示系统前一个月，本月和下一个月的日历<br>-j ： 显示在本年中是第几天<br>-y ：显示当前年份的日历</p>
</blockquote>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>语法：find 路径名 -选项<br>功能：用于在文件树中查找文件，并做出相应处理<br>常用选项：</p>
<blockquote>
<p>-name ： 按照文件名查找文件</p>
</blockquote>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>语法：grep [选项] 搜寻字符串 文件<br>功能：在文件中搜索字符串，将找到的行打印出来<br>常用选项：</p>
<blockquote>
<p>-i ： 忽略大小写不同<br>-n ： 输出行号<br>-v ： 反向选择，显示出没有“搜寻字符串”内容的那一行</p>
</blockquote>
<h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><p>语法：zip&nbsp; [压缩文件.zip]&nbsp; [目录或文件]&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unzip [要解压的压缩文件] &nbsp;[目录或文件名]<br>功能：将目录或文件压缩成zip格式<br>常用选项：</p>
<blockquote>
<p>-r ： 递归处理，将指定目录下的所有文件和子目录一并处理</p>
</blockquote>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>语法：tar [参数] [文件与目录]<br>功能：打包，解包，即处理压缩文件<br>常用选项：</p>
<blockquote>
<p>-c ： 建立一个压缩文件<br>-x ： 解开一个压缩文件<br>-z ： 是否需要用gzip算法压缩或解压<br>-j ： 是否需要用bzip2算法压缩或解压<br>-v ： 压缩的过程显示文件<br>-f ： 使用档名，即规定压缩或解压后文件的名称，注意：使用该参数后后面不能再跟其他参数，直接跟文件名<br>-C ： 解压到指定目录<br>综合用法：<br>tar -cvzf 压缩后的文件名称 要压缩的文件名称  //用gzip算法进行压缩，并展示压缩过程<br>tar -xvzf 解压后的文件名称 要解压的文件名称  //解压缩<br>tar -cjzf 压缩后的文件名称 要压缩的文件名称  //用bzip2算法进行压缩，并展示压缩过程<br>tar -xjzf 解压后的文件名称 要解压的文件名称  //解压缩</p>
</blockquote>
<h6 id="tips-5"><a href="#tips-5" class="headerlink" title="tips"></a>tips</h6><p>1、一般的压缩算法有gzip和bzip2两种，使用tar命令需要说明使用的哪种算法进行压缩或解压的 -z 或 -j<br>2、用哪种算法压缩的就需要用哪种算法进行解压<br>3、用gzip压缩后的文件若要进行解压，文件名必须为xxx.tar.gz<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用bzip2压缩后的文件若要进行解压，文件名必须为xxx.tar.bz2<br>4、再次强调，参数-f后需要直接跟文件名，不能再跟其他参数，但是-f之前的其他参数可以以任意次序进行混合使用</p>
<h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>语法：uname [选项]<br>功能：用来获取电脑和操作系统的相关信息，可以显示Linux主机所用的版本，硬件名称等基本信息<br>常用选项</p>
<blockquote>
<p>-a 详细展示所有信息</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>STL之deque</title>
    <url>/2019/11/11/STL%E4%B9%8Bdeque/</url>
    <content><![CDATA[<h3 id="deque介绍"><a href="#deque介绍" class="headerlink" title="deque介绍"></a>deque介绍</h3><p>1、deque是动态大小的序列式容器，可以向两端进行扩容或压缩<br>2、特定的库可以以不同的方式实现deque，但通常都是一种动态数组。不论在何种情况下，它都允许通过随机访问迭代器直接访问单个元素<br>3、deque提供了一些与vector相似的功能，但deque在头部和尾部进行数据插入和删除操作更加高效。与vector不同的是，deque不能保证所有元素都存储在连续的空间中，在deque中通过指针加偏移量的方式访问元素可能导致非法的操作</p>
<p>就我而言，其实，相比其他容器而言，deque比较“鸡肋”（个人观点），若要说遍历元素，用vector足以完成，若要说插入删除，list也够用，而且相比来说，deque性能在这两方面性能较差<br>  <img src="https://img-blog.csdnimg.cn/20191025194344163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="deque的接口"><a href="#deque的接口" class="headerlink" title="deque的接口"></a>deque的接口</h3><p>  <img src="https://img-blog.csdnimg.cn/20191025194441955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="deque的应用场景"><a href="#deque的应用场景" class="headerlink" title="deque的应用场景"></a>deque的应用场景</h3><p>deque在序列式容器中比较鸡肋，因为如果只是简单的存储元素，使用vector即可，如果对元素任意位置进行插入或者删除操作比较多，使用list即可，所以一般很少去使用deque，它最大的应用，就是作为标准库中stack和queue的底层结构<br>详见<a href="https://blog.csdn.net/qq_43746320/article/details/102749009">库函数stack的模拟实现</a>和<a href="https://blog.csdn.net/qq_43746320/article/details/102749043">库函数queue的模拟实现</a></p>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
  </entry>
  <entry>
    <title>STL之list</title>
    <url>/2019/01/03/STL%E4%B9%8Blist/</url>
    <content><![CDATA[<h3 id="list介绍"><a href="#list介绍" class="headerlink" title="list介绍"></a>list介绍</h3><p>1、list是可以在常数范围内在任意位置进行插入删除的序列式容器，并且该容器可以<strong>前后双向迭代</strong><br>2、其底层结构：<strong>带头结点的双向循环链表</strong><br>3、list和forward_list相似：但是forword_list是单链表，只能朝前迭代<br>4、与其他容器相比，<strong>list在任意位置插入删除更加高效</strong>，但最大的缺陷是<strong>不能进行任意位置元素的访问</strong>，若要访问第pos位元素，需要从头节点开始朝前或朝后进行遍历，直到第pos位为止</p>
<h3 id="list的接口"><a href="#list的接口" class="headerlink" title="list的接口"></a>list的接口</h3><p>list中的接口如下所示：<br><img src="https://img-blog.csdnimg.cn/20191025182941207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="list中迭代器失效问题"><a href="#list中迭代器失效问题" class="headerlink" title="list中迭代器失效问题"></a>list中迭代器失效问题</h3><p>先来解释一下什么是迭代器：<br>迭代器，是一种可以检查容器内元素并遍历元素的类型，它可以被理解为类似指针的类型<br>每种容器都有自己的迭代器，比如vector、deque提供的是随机访问迭代器，list提供的是双向迭代器，等…</p>
<p>迭代器失效问题：<br>迭代器失效即迭代器所指向的节点无效，即该节点被删除了，因为list的底层结构为带头结点的双向循环链表，因此<strong>在list中进行插入时是不会导致list的迭代器失效的</strong>，<strong>只有在删除时才会失效</strong>，<strong>并且失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响</strong><br>换一种思维理解，既然先前提过list类似指针，那么当一个指针指向的空间被释放了，那么指针所指向的内容就是无效的，指针就会变成野指针，所以类比迭代器失效问题，迭代器所指向的节点被释放了，那么该节点的迭代器就是一个无效的迭代器了，此时若要通过该迭代器访问该节点，那么就会出现迭代器失效问题，编译器报错</p>
<p>传送门：<a href="https://blog.csdn.net/qq_43746320/article/details/102537111">list的模拟实现</a></p>
<hr>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL之vector</title>
    <url>/2019/01/03/STL%E4%B9%8Bvector/</url>
    <content><![CDATA[<h3 id="vector介绍"><a href="#vector介绍" class="headerlink" title="vector介绍"></a>vector介绍</h3><p>简言之，vector是表示可变大小数组的容器序列<br>其底层结构：可存放任意数据类型的动态类型顺序表</p>
<h6 id="具体介绍如下："><a href="#具体介绍如下：" class="headerlink" title="具体介绍如下："></a>具体介绍如下：</h6><p>1、和数组一样，vector也是用一片连续空间存储数组，意味着它可以和数组一样<strong>高效地</strong>通过下标访问每个空间中的元素，但和数组不同的是，它的大小可以动态改变，而且是被容器自动改变，无需使用者关心<br>2、本质讲，vector动态分配数组来存储它的元素。当新元素插入时，vector需要检测其空闲空间是否足够存放，若足够，则移动元素插入，若不足，则会分配一个新的数组，然后将全部元素移入这个新的数组中，再进行插入。所以就时间而言，其代价相对较高<br>3、分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。如VS下vector容量是按照约等<strong>1.5倍增长</strong>的，g++是按<strong>2倍增长</strong>的<br>4、vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长<br>5、与其他动态序列容器相比，vector在<strong>访问元素时更加高效</strong>，在末尾插入删除元素相对高效，但是对于不在末尾的插入删除，效率较低。比起list和forward_list统一的迭代器和引用更好</p>
<h3 id="vector方法"><a href="#vector方法" class="headerlink" title="vector方法"></a>vector方法</h3><p>由于在之前博客<a href="https://blog.csdn.net/qq_43746320/article/details/101452911">string</a>中已经详细列举了大量的string方法，此处不再赘述<br><img src="https://img-blog.csdnimg.cn/20191025173108398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="vector扩容机制"><a href="#vector扩容机制" class="headerlink" title="vector扩容机制"></a>vector扩容机制</h3><p>值得一提的是，vector既然是连续的空间且大小可变，那么其底层的扩容机制到底如何实现？如下：<br><img src="https://img-blog.csdnimg.cn/20191025181043119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzQ2MzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>传送门：<a href="https://blog.csdn.net/qq_43746320/article/details/102532478">vector的模拟实现</a></p>
<hr>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
